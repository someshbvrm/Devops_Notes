
---
# Ansible Interview Questions and Answers

### **Table of Contents**
1.  **Core Concepts & Fundamentals**
2.  **Installation & Setup**
3.  **Inventory & Hosts**
4.  **Playbooks**
5.  **Variables & Facts**
6.  **Modules (Core & Common)**
7.  **Roles**
8.  **Templating (Jinja2)**
9.  **Ansible Vault**
10. **Error Handling & Debugging**
11. **Performance & Optimization**
12. **Ansible Tower / AWX**
13. **Advanced Scenarios & Best Practices**
14. **Ansible Galaxy & Community**
15. **DevOps & CI/CD Integration**

---

### **1. Core Concepts & Fundamentals**

**Q1. What is Ansible and how does it work?**
**A:** Ansible is an open-source automation tool used for configuration management, application deployment, intra-service orchestration, and provisioning. It works by connecting to nodes (servers, network devices, etc.) over SSH (by default) and pushing small programs called "modules" to them. These modules are executed to bring the system to a desired state. The results are then reported back. It is agentless, meaning no software needs to be installed on the remote nodes.

**Q2. What is meant by "Idempotency" in the context of Ansible? Why is it important?**
**A:** Idempotency means that running an Ansible playbook or task multiple times will have the same effect as running it once. For example, if a package is already installed, the `apt` module will not try to install it again. This is crucial for safety and consistency. It ensures that playbooks can be run repeatedly without causing unintended changes or errors, making automation reliable.

**Q3. Explain the key components of Ansible architecture.**
**A:**
*   **Control Node:** The machine where Ansible is installed and from which playbooks are run.
*   **Managed Nodes:** The servers or devices that are managed by the control node.
*   **Inventory:** A file (INI or YAML) that lists all managed nodes, often grouped.
*   **Playbooks:** YAML files containing a set of plays and tasks that define the automation.
*   **Plays:** A mapping of hosts to roles/tasks. A playbook can have multiple plays.
*   **Tasks:** Units of action that call Ansible modules (e.g., `yum`, `copy`).
*   **Modules:** Discrete units of code that Ansible executes. They are "idempotent".
*   **Roles:** A pre-defined way to organize playbooks, tasks, variables, and files for reusability.
*   **Handlers:** Special tasks that are triggered by `notify` and run at the end of a play.
*   **Plugins:** Pieces of code that extend Ansible's core functionality (e.g., connection, lookup, filter plugins).

**Q4. What is the difference between Ansible Playbooks and Ad-hoc commands?**
**A:** Ad-hoc commands are quick, one-line commands used to perform simple, one-off tasks (e.g., `ansible all -m ping` or `ansible web -m apt -a "name=nginx state=present"`). Playbooks are written in YAML, are reusable, declarative, and can model complex multi-step workflows, making them suitable for configuration management and deployment.

**Q5. Why is Ansible considered agentless?**
**A:** Ansible does not require any agent software to be installed or running on the remote hosts. It primarily uses SSH (for Linux/Unix) and WinRM (for Windows) to communicate and execute commands. This reduces overhead, simplifies management, and improves security.

**Q6. What is a YAML file and why is it used for Ansible playbooks?**
**A:** YAML (YAML Ain't Markup Language) is a human-readable data serialization standard. It is used for Ansible playbooks because it is easy for humans to read and write, clearly represents hierarchical data relationships, and maps well to data structures common in programming languages (lists, dictionaries).

**Q7. What is the default location for the Ansible configuration file?**
**A:** The default location is `/etc/ansible/ansible.cfg`. However, Ansible will also look for it in the current working directory (`./ansible.cfg`) or in the user's home directory (`~/.ansible.cfg`), with the latter taking precedence.

**Q8. What are the main requirements for a host to be managed by Ansible?**
**A:**
*   **SSH access:** The control node must be able to SSH into the host (for Linux).
*   **Python:** Python 2 (version 2.7) or Python 3 (version 3.5 and higher) must be installed on the managed host. (Note: Python 2 is end-of-life, so Python 3 is strongly recommended).

**Q9. What is the difference between `ansible` and `ansible-playbook` commands?**
**A:** The `ansible` command is used to run ad-hoc commands against hosts. The `ansible-playbook` command is used to run playbooks, which are files containing a series of tasks and plays.

**Q10. What is the purpose of the `gather_facts` directive in a play?**
**A:** `gather_facts: yes` (default) tells Ansible to run the `setup` module to collect information (facts) about the remote host, such as IP address, OS, disk space, etc. These facts can then be used as variables within the playbook. Setting it to `no` can speed up playbook execution if facts are not needed.

---

### **2. Installation & Setup**

**Q11. How do you install Ansible on a Ubuntu machine?**
**A:**
```bash
sudo apt update
sudo apt install software-properties-common
sudo add-apt-repository --yes --update ppa:ansible/ansible
sudo apt install ansible
```

**Q12. How do you install Ansible using Python's pip?**
**A:**
```bash
pip install ansible
# or for a specific user
pip install --user ansible
```

**Q13. What is the command to check the version of Ansible installed?**
**A:**
```bash
ansible --version
```

**Q14. How would you install a specific version of Ansible using pip?**
**A:**
```bash
pip install ansible==2.9.10
```

**Q15. After installation, what is the first file you should create to configure Ansible?**
**A:** The `ansible.cfg` file. You can create it in your project directory to override the default settings for that specific project.

---

### **3. Inventory & Hosts**

**Q16. What is an Inventory file in Ansible?**
**A:** An inventory file is a file that defines the hosts and groups of hosts upon which commands, modules, and playbooks operate. Its default location is `/etc/ansible/hosts`.

**Q17. Show an example of a basic INI-style inventory file with groups.**
**A:**
```ini
[web]
web1.example.com
web2.example.com ansible_port=2222 # Custom SSH port

[db]
db-server.example.com

[log]
log-server.example.com

[datacenter:children] # Group of groups
web
db
log
```

**Q18. Show the same example in YAML format.**
**A:**
```yaml
all:
  children:
    web:
      hosts:
        web1.example.com:
        web2.example.com:
          ansible_port: 2222
    db:
      hosts:
        db-server.example.com:
    log:
      hosts:
        log-server.example.com:
    datacenter:
      children:
        web:
        db:
        log:
```

**Q19. How do you define a variable for a host in the inventory?**
**A:** You can define it inline after the hostname.
```ini
host1.example.com http_port=80 max_requests=200
```
Or in a separate section for that host (INI):
```ini
[web]
host1.example.com

[web:vars]
ntp_server=ntp.example.com
proxy=proxy.example.com
```

**Q20. What is a dynamic inventory and when would you use it?**
**A:** A dynamic inventory is a script or program (written in any language) that fetches host information from an external source, like AWS EC2, Azure, GCP, or a CMDB. It returns a JSON structure of the hosts. You use it when your infrastructure is not static and changes frequently (e.g., in cloud environments with auto-scaling).

**Q21. How do you use an inventory file located in a different path?**
**A:** Use the `-i` or `--inventory` flag with the `ansible` or `ansible-playbook` command.
```bash
ansible-playbook -i /path/to/my_inventory playbook.yml
```

**Q22. What is the difference between `all` and `ungrouped` in an inventory?**
**A:** `all` contains every single host in the inventory. `ungrouped` contains all hosts that are *not* part of any group other than the implicit `all` group.

**Q23. How can you list all the hosts in your inventory?**
**A:**
```bash
ansible all --list-hosts
```

**Q24. How can you list all the hosts belonging to a specific group, e.g., `web`?**
**A:**
```bash
ansible web --list-hosts
```

**Q25. What is the purpose of the `meta: refresh_inventory` task?**
**A:** It is used in a playbook to clear the current in-memory inventory and re-read it, allowing subsequent plays/tasks to use a potentially updated dynamic inventory. This is useful if an earlier task in the playbook changes the infrastructure (e.g., creates a new EC2 instance).

---

### **4. Playbooks**

**Q26. What is an Ansible Playbook?**
**A:** An Ansible Playbook is a YAML file containing one or more "plays". A play defines a set of activities (tasks) to be run on a group of hosts. It is the primary tool for orchestrating complex automation tasks.

**Q27. Explain the basic structure of a playbook.**
**A:**
```yaml
---
- name: This is a playbook  # Playbook comment
  hosts: web                # Mandatory: Target hosts
  become: yes               # Optional: Run tasks with sudo
  vars:                     # Optional: Define variables
    http_port: 80
  tasks:                    # Mandatory: List of tasks
    - name: Ensure Nginx is installed
      apt:
        name: nginx
        state: present

    - name: Ensure Nginx is running
      service:
        name: nginx
        state: started
        enabled: yes
  handlers:                 # Optional: Tasks notified by other tasks
    - name: restart nginx
      service:
        name: nginx
        state: restarted
```

**Q28. What is the purpose of the `---` at the beginning of a YAML file?**
**A:** It is the YAML document start marker. While not strictly required for Ansible, it is a best practice and helps identify the file as YAML.

**Q29. What is the difference between `state: started` and `state: present`?**
**A:** `state: present` (used in package modules like `apt`, `yum`) ensures the software package is installed. `state: started` (used in the `service` module) ensures the service is running. They are often used together.

**Q30. What is a Handler? How is it triggered?**
**A:** A handler is a special kind of task that only runs when notified by another task. It is typically used to restart services after a configuration change. It is triggered using the `notify` directive in a task.
```yaml
tasks:
  - name: Copy Nginx config
    template:
      src: nginx.conf.j2
      dest: /etc/nginx/nginx.conf
    notify: restart nginx # This triggers the handler

handlers:
  - name: restart nginx
    service:
      name: nginx
      state: restarted
```

**Q31. Why do handlers run at the end of a play by default?**
**A:** This allows multiple tasks to notify the same handler, but the handler will only run once, avoiding unnecessary multiple restarts. It is an optimization.

**Q32. How can you force a handler to run immediately after a task?**
**A:** You can use the `meta: flush_handlers` task. This forces all notified handlers to run at that point in the playbook.
```yaml
tasks:
  - name: Some task
    template: src=file.conf.j2 dest=/etc/file.conf
    notify: restart service

  - meta: flush_handlers # Handler runs here

  - name: Another task
    command: do-something
```

**Q33. What is the difference between `serial` and `max_fail_percentage` in a play?**
**A:**
*   `serial`: Defines the "batch size" or number of hosts to process at a time in a rolling update. `serial: 1` updates one host at a time.
*   `max_fail_percentage`: Defines the percentage of hosts that can fail before the entire play is aborted for the remaining hosts. If set to `25`, the play will stop if more than 25% of hosts in a batch fail.

**Q34. How do you run a playbook that is located in a specific file?**
**A:**
```bash
ansible-playbook my_playbook.yml
```

**Q35. How do you run a specific play or task within a playbook?**
**A:** You can use tags. First, tag your tasks or plays:
```yaml
tasks:
  - name: Install package
    apt: name=apache2 state=present
    tags: install

  - name: Configure service
    template: src=config.j2 dest=/etc/config
    tags: config
```
Then run only tagged tasks:
```bash
ansible-playbook playbook.yml --tags "install"
# Or skip tasks
ansible-playbook playbook.yml --skip-tags "config"
```
*You cannot directly run a single untagged task without tags.*

**Q36. What is the purpose of the `--check` mode (Dry Run)?**
**A:** The `--check` flag runs the playbook in "dry run" mode. It predicts what changes would occur without actually making any changes to the remote systems. It's useful for testing and validation.

**Q37. What is the purpose of the `--diff` flag?**
**A:** The `--diff` flag shows the differences in any files that are changed. When used with `--check`, it shows what the changes *would* be. When used without `--check`, it shows the actual changes made by template or copy modules.

**Q38. How do you start a playbook execution from a specific task?**
**A:** Use the `--start-at-task` flag.
```bash
ansible-playbook playbook.yml --start-at-task="Install package"
```

**Q39. What is the `--step` flag used for?**
**A:** The `--step` flag runs the playbook in interactive mode, prompting the user to confirm whether to run each task before executing it. (y/n/c)

**Q40. What is the `force_handlers` directive used for?**
**A:** By default, if a task fails, any handlers that were notified by earlier tasks will *not* run. Setting `force_handlers: yes` at the play level forces notified handlers to run even if the play fails later.

---

### **5. Variables & Facts**

**Q41. What are the different ways to define variables in Ansible?**
**A:**
1.  **`vars` section** in a playbook.
2.  **`vars_files`** section to include an external variables file.
3.  **Inventory variables** (host or group vars).
4.  **Command line** using `-e` or `--extra-vars`.
5.  **`set_fact`** module to set facts for a host during playbook execution.
6.  **Registered variables** (`register`) to capture the output of a task.
7.  **Role variables and defaults**.

**Q42. What is the variable precedence order in Ansible?**
**A:** (From lowest to highest)
1.  Role defaults
2.  Inventory variables (group)
3.  Inventory variables (host)
4.  Inventory `all` group
5.  Playbook `vars`
6.  Playbook `vars_prompt`
7.  Playbook `vars_files`
8.  Registered variables
9.  `set_fact`
10. Role and include variables
11. Block variables
12. Task variables
13. `-e` Extra vars **(Highest Precedence)**

**Q43. What are Ansible Facts and how are they gathered?**
**A:** Facts are system information discovered by Ansible from the managed node (IP addresses, OS, hardware details, etc.). They are gathered by the `setup` module, which runs automatically at the beginning of a play if `gather_facts: yes` is set.

**Q44. How do you disable fact gathering?**
**A:** Set `gather_facts: no` in the play.

**Q45. How can you see all facts for a specific host?**
**A:** Use the `setup` module in an ad-hoc command:
```bash
ansible hostname -m setup
```

**Q46. How do you create a custom fact?**
**A:** On the managed node, you can create a file in `/etc/ansible/facts.d/` with a `.fact` extension. This can be in JSON or INI format. Ansible will automatically read these. For example, `/etc/ansible/facts.d/custom.fact`:
```ini
[application]
environment=prod
version=1.2.3
```
You can then access it as `ansible_local.custom.application.environment`.

**Q47. What is the `register` keyword used for?**
**A:** The `register` keyword captures the output (return values) of a task and stores it in a variable. This variable can then be used in subsequent tasks.
```yaml
- name: Capture the output of 'whoami'
  command: whoami
  register: login_user

- debug:
    msg: "The logged-in user is {{ login_user.stdout }}"
```

**Q48. What is the `set_fact` module used for?**
**A:** The `set_fact` module allows you to set new variables on a per-host basis, dynamically, during playbook execution. These facts have a high precedence.
```yaml
- set_fact:
    my_custom_var: "some value"
```

**Q49. How would you access the IP address of a managed node from a fact?**
**A:** The fact structure is complex. The default IPv4 address is typically:
```yaml
{{ ansible_default_ipv4.address }}
```
You can also use other facts like `ansible_eth0.ipv4.address`.

**Q50. What is the difference between `hostvars` and `groups`?**
**A:**
*   `hostvars` is a dictionary containing all variables for all hosts, including facts. `{{ hostvars['web1.example.com']['ansible_os_family'] }}`
*   `groups` is a dictionary of all groups in the inventory and their hosts. `{{ groups['web'] }}` returns a list of all hosts in the 'web' group.

---

### **6. Modules (Core & Common)**

**Q51. What is an Ansible Module?**
**A:** A module is a standalone, reusable script that Ansible runs on your behalf. Modules are used to accomplish specific automation tasks like managing packages, files, services, or executing commands. They are what do the actual work.

**Q52. Name some common modules and their uses.**
**A:**
*   **`ping`** – Tests connectivity to a host.
*   **`apt`/`yum`** – Manages packages on Debian/RedHat families.
*   **`copy`** – Copies files from control node to managed node.
*   **`template`** – Templates a file out to a managed node (uses Jinja2).
*   **`file`** – Manages files, directories, and symlinks.
*   **`service`** – Manages services.
*   **`user`** / **`group`** – Manages users and groups.
*   **`command`** / **`shell`** – Executes commands. (`shell` runs through a shell, allowing pipes and variables; `command` is more secure and predictable).
*   **`debug`** – Prints messages during execution.
*   **`lineinfile`** / **`blockinfile`** – Manages single lines or blocks of text in a file.

**Q53. What is the difference between the `command` and `shell` modules?**
**A:** The `command` module executes a command directly, without going through the remote shell. This means it does not support pipes (`|`), redirects (`>`, `>>`), or environment variables (`$HOME`). The `shell` module does support these features. `command` is more secure and predictable, so it should be used unless shell features are explicitly required.

**Q54. When would you use the `raw` module?**
**A:** The `raw` module is used for executing low-level commands, bypassing the Ansible module subsystem. It is primarily used for bootstrapping Python on a system that doesn't have it installed yet, or for communicating with devices that cannot run Python (like some network gear).

**Q55. How does the `template` module work?**
**A:** The `template` module takes a Jinja2 template file (usually with a `.j2` extension) from the control node, processes the variables and logic within it, and copies the resulting file to the managed node. It is the primary way to create dynamic configuration files.

**Q56. What is the difference between the `copy` and `template` modules?**
**A:** The `copy` module copies a file as-is from the control node to the managed node. The `template` module first processes the file as a Jinja2 template, substituting variables, and then copies the resulting content.

**Q57. How do you install a package using the `apt` module?**
**A:**
```yaml
- name: Install Apache
  apt:
    name: apache2
    state: present
    update_cache: yes # Equivalent to 'apt-get update'
```

**Q58. How do you ensure a service is enabled and started using the `service` module?**
**A:**
```yaml
- name: Ensure Nginx is running and enabled
  service:
    name: nginx
    state: started
    enabled: yes
```

**Q59. How do you create a directory with specific permissions using the `file` module?**
**A:**
```yaml
- name: Create app directory
  file:
    path: /opt/myapp
    state: directory
    mode: '0755'
    owner: myuser
    group: mygroup
```

**Q60. How do you add a line to a file only if it doesn't exist using `lineinfile`?**
**A:**
```yaml
- name: Add a nameserver to resolv.conf
  lineinfile:
    path: /etc/resolv.conf
    line: 'nameserver 8.8.8.8'
    state: present
    create: yes # Create the file if it doesn't exist
```

**Q61. How do you fetch a file from a remote machine to the control node?**
**A:** Use the `fetch` module.
```yaml
- name: Fetch a log file
  fetch:
    src: /var/log/app.log
    dest: /tmp/fetched-logs/ # Directory on control node
    flat: yes # Puts file directly in dest, without hostname directory
```

**Q62. What is the `wait_for` module used for?**
**A:** The `wait_for` module is used to pause playbook execution until a certain condition is met, such as a port being open, a file being present, or a string being found in a file.
```yaml
- name: Wait for port 8000 to be open
  wait_for:
    port: 8000
    host: '{{ inventory_hostname }}'
    delay: 10
    timeout: 300
```

**Q63. What is the `assert` module used for?**
**A:** The `assert` module is used to validate variables or conditions and fail the playbook if the condition is not met. It's useful for pre-flight checks.
```yaml
- name: Assert that the OS is Ubuntu
  assert:
    that:
      - ansible_os_family == "Debian"
      - ansible_distribution == "Ubuntu"
    fail_msg: "This playbook only runs on Ubuntu."
```

**Q64. How do you use the `uri` module to check a website's status?**
**A:**
```yaml
- name: Check website status
  uri:
    url: http://example.com
    method: GET
  register: website_response

- debug:
    msg: "Status code: {{ website_response.status }}"
```

**Q65. What is the purpose of the `add_host` module?**
**A:** The `add_host` module adds a host (and optionally groups and variables) to the in-memory inventory for the current playbook run. This is useful for creating new VMs or instances on the fly and then configuring them later in the same playbook.

**Q66. What is the purpose of the `group_by` module?**
**A:** The `group_by` module creates Ansible groups dynamically based on facts or variables. For example, you can group hosts by their OS.
```yaml
- name: Create groups based on OS
  group_by:
    key: os_{{ ansible_os_family }}

- name: Do something on Debian hosts
  hosts: os_Debian
  tasks: ...
```

---

### **7. Roles**

**Q67. What is an Ansible Role?**
**A:** A role is a predefined structure for organizing playbooks, tasks, variables, files, templates, and handlers. It provides a way to break a complex playbook into reusable, shareable components. Roles are the primary mechanism for breaking a playbook into multiple files.

**Q68. What is the standard directory structure of an Ansible Role?**
**A:**
```
role_name/
├── defaults
│   └── main.yml      # Lowest precedence variables
├── files             # Static files to be copied
├── handlers
│   └── main.yml      # Handlers
├── meta
│   └── main.yml      # Role dependencies and metadata
├── README.md
├── tasks
│   └── main.yml      # Main task list
├── templates         # Jinja2 template files (.j2)
├── tests
│   ├── inventory
│   └── test.yml
└── vars
    └── main.yml      # High precedence variables
```

**Q69. How do you create a new role skeleton?**
**A:** Use the `ansible-galaxy` command:
```bash
ansible-galaxy role init my_new_role
```

**Q70. How do you use a role in a playbook?**
**A:** Use the `roles` keyword in a play.
```yaml
- hosts: web
  roles:
    - common
    - { role: nginx, port: 80 } # Passing role-specific variables
    - role: apache
      when: ansible_os_family == "RedHat"
```

**Q71. What is the difference between `roles:` and `import_role:` / `include_role:`?**
**A:**
*   **`roles:`** is static. Roles are included at playbook parsing time. You cannot use loops or conditionals with this method.
*   **`import_role:`** is also static and is parsed at playbook parse time. It is not dynamic.
*   **`include_role:`** is dynamic. The role is included at *runtime*. This allows you to use loops and conditionals with it.
    ```yaml
    tasks:
      - include_role:
          name: my_role
        when: some_condition
      - import_role:
          name: my_other_role
    ```

**Q72. What is the purpose of the `meta/main.yml` file in a role?**
**A:** It contains metadata about the role, most importantly, its dependencies. This allows a role to automatically install other roles it depends on before it runs.
```yaml
dependencies:
  - { role: common, some_variable: value }
  - role: java
    when: ansible_os_family == "RedHat"
```

**Q73. How do you install a role from Ansible Galaxy?**
**A:**
```bash
ansible-galaxy role install username.role_name
# or from a requirements file
ansible-galaxy install -r requirements.yml
```

**Q74. How do you list installed roles?**
**A:**
```bash
ansible-galaxy role list
```

---

### **8. Templating (Jinja2)**

**Q75. What is Jinja2?**
**A:** Jinja2 is a modern, designer-friendly templating language for Python, modeled after Django's templates. It is used by Ansible to dynamically create files (configurations, scripts, etc.) on the managed nodes based on variables and logic.

**Q76. How do you use a variable in a Jinja2 template?**
**A:** Variables are enclosed in double curly braces `{{ }}`.
```
ServerName {{ server_name }}:{{ http_port }}
```

**Q77. How do you use a conditional statement in a Jinja2 template?**
**A:** Use `{% if %} ... {% endif %}`.
```
{% if enable_ssl %}
SSLEngine on
SSLCertificateFile {{ ssl_cert_path }}
{% endif %}
```

**Q78. How do you use a loop in a Jinja2 template?**
**A:** Use `{% for %} ... {% endfor %}`.
```
{% for user in users %}
username {{ user.name }} password {{ user.password }}
{% endfor %}
```

**Q79. What is a Jinja2 filter? Give an example.**
**A:** Filters are used to modify variables. They are called with a pipe symbol `|`.
```
{{ output | upper }} # Converts to uppercase
{{ user_list | length }} # Gets the number of items
{{ path | basename }} # Gets the filename from a path
{{ variable | default('default_value') }} # Provides a default value
```

**Q80. How do you combine two variables in a template?**
**A:** You can use the `~` operator or just place them next to each other.
```
{{ http:// ~ server_name ~ ':' ~ http_port }}
# or in newer versions, just:
{{ http://{{ server_name }}:{{ http_port }} }} # This can be messy
# Better to use string concatenation with ~
```

**Q81. What is the `ternary` filter used for?**
**A:** It's a shorthand for an if-else statement.
```
{{ (status == 'enabled') | ternary('yes', 'no') }}
```

**Q82. How do you generate a random password in a Jinja2 template?**
**A:** You typically wouldn't generate it *in* the template for idempotency reasons. You would generate it in a playbook task using the `password lookup` and then pass it to the template. But for one-off use:
```
{{ 64 | random | string | b64encode }}
```

**Q83. What is the purpose of the `{% raw %} ... {% endraw %}` block?**
**A:** It prevents Jinja2 from processing the content inside the block. This is useful if you need to output text that contains `{{` or `{%` which would normally be interpreted as Jinja2 delimiters.

**Q84. How do you include another file inside a Jinja2 template?**
**A:** Use the `{% include 'file.txt' %}` directive.

---

### **9. Ansible Vault**

**Q85. What is Ansible Vault?**
**A:** Ansible Vault is a feature that allows you to encrypt sensitive data such as passwords, API keys, or any other confidential information within playbooks, variables files, or inventory, rather than storing them in plaintext.

**Q86. How do you create a new encrypted file with vault?**
**A:**
```bash
ansible-vault create secrets.yml
```
You will be prompted to set a password.

**Q87. How do you encrypt an existing file?**
**A:**
```bash
ansible-vault encrypt existing_file.yml
```

**Q88. How do you view the contents of an encrypted vault file?**
**A:**
```bash
ansible-vault view secrets.yml
```

**Q89. How do you edit an encrypted vault file?**
**A:**
```bash
ansible-vault edit secrets.yml
```

**Q90. How do you decrypt a vault file?**
**A:**
```bash
ansible-vault decrypt secrets.yml
```

**Q91. How do you run a playbook that uses a vault-encrypted file?**
**A:** Use the `--ask-vault-pass` flag to be prompted for the password:
```bash
ansible-playbook site.yml --ask-vault-pass
```
Or use a vault password file and the `--vault-password-file` flag (ensure the file has secure permissions):
```bash
ansible-playbook site.yml --vault-password-file ~/.vault_pass.txt
```

**Q92. How can you use multiple vault passwords?**
**A:** You can use the `--vault-id` flag to specify a label and a source for the password. This is useful for having different passwords for different environments (e.g., dev, prod).
```bash
ansible-playbook site.yml --vault-id dev@prompt --vault-id prod@~/.prod_vault
```

**Q93. How do you change the password of an encrypted vault file?**
**A:**
```bash
ansible-vault rekey secrets.yml
```

**Q94. What is the best practice for handling vault passwords in CI/CD?**
**A:** The vault password should be stored in a secure secret manager (e.g., HashiCorp Vault, AWS Secrets Manager, Azure Key Vault) and injected as an environment variable or a temporary file into the CI/CD job at runtime. The password file itself should *never* be committed to version control.

**Q95. Can you encrypt a single variable within a file?**
**A:** Not directly with `ansible-vault`. The entire file is encrypted. However, you can use the `!vault` tag in a YAML file to store an encrypted *value* within a plaintext file. You create the encrypted value with:
```bash
ansible-vault encrypt_string 'my_secret_password' --name 'secret_key'
```
This outputs a block you can paste into a YAML file:
```yaml
secret_key: !vault |
          $ANSIBLE_VAULT;1.1;AES256
          66386439653236336462626566653063336164663966303231363934653563363964363833313662
          6431626534306136656138323438633063323132313336620a626133366534353665353665393231
          32633937666335333738386133383964363831626462633462626539643831326362666530616535
          366265316664650a6337393266616335326266616561383137636566623763653363623364666334
```

---

### **10. Error Handling & Debugging**

**Q96. How do you ignore errors in a task?**
**A:** Use the `ignore_errors: yes` directive on the task. This allows the playbook to continue even if the task fails.
```yaml
- name: This task might fail
  command: /bin/false
  ignore_errors: yes
```

**Q97. What is the difference between `ignore_errors` and `failed_when`?**
**A:**
*   `ignore_errors: yes` tells Ansible to treat any failure in the task as non-fatal and continue.
*   `failed_when:` allows you to define a condition that, if true, marks the task as *failed*. It gives you control over what constitutes a failure.
    ```yaml
    - name: Run a script that might return non-zero
      command: /usr/bin/my_script
      register: result
      failed_when: "'ERROR' in result.stdout" # Only fail if output contains 'ERROR'
      # or
      failed_when: result.rc != 0 and result.rc != 5 # Ignore exit code 5
    ```

**Q98. How do you use the `debug` module to print a variable's value?**
**A:**
```yaml
- debug:
    var: my_variable

- debug:
    msg: "The value is {{ my_variable }}"
```

**Q99. What is the `assert` module used for in error handling?**
**A:** It is used for pre-flight checks to fail early if certain conditions aren't met, preventing the playbook from running in an invalid environment.
```yaml
- name: Check if free memory is sufficient
  assert:
    that:
      - ansible_memfree_mb > 512
    fail_msg: "Insufficient memory. Required 512MB, found {{ ansible_memfree_mb }}MB."
```

**Q100. How can you force a task to fail explicitly?**
**A:** Use the `fail` module.
```yaml
- name: Fail if OS is not supported
  fail:
    msg: "The OS {{ ansible_os_family }} is not supported."
  when: ansible_os_family not in ["RedHat", "Debian"]
```

**Q101. What is the purpose of the `--syntax-check` flag?**
**A:** It checks the playbook for syntax errors without actually executing it.
```bash
ansible-playbook playbook.yml --syntax-check
```

**Q102. How do you increase the verbosity of Ansible output for debugging?**
**A:** Use the `-v` flag. You can use up to four `-v` flags for increasing levels of verbosity (`-vvvv`).
```bash
ansible-playbook playbook.yml -vvv
```

**Q103. How do you run a task that is meant to be run only once, even in a multi-host play?**
**A:** Use `run_once: true` on the task. This is useful for tasks like adding a repo or loading a database schema that should only be executed on a single host, even if the play runs on multiple hosts.
```yaml
- name: Add EPEL repo
  yum:
    name: epel-release
    state: present
  run_once: true
```

**Q104. What is the purpose of the `any_errors_fatal` directive?**
**A:** Setting `any_errors_fatal: true` at the play level makes any failure on any host cause the entire playbook to fail immediately for all hosts. This is useful for scenarios where a failure on one host makes subsequent tasks on other hosts meaningless.

**Q105. How can you rescue from errors in a block of tasks?**
**A:** Use the `block`, `rescue`, and `always` sections, similar to try-catch-finally in programming languages.
```yaml
tasks:
  - name: Handle errors
    block:
      - name: This task might fail
        command: /bin/false
      - name: This task runs only if the previous task succeeds
        debug:
          msg: "Success!"
    rescue:
      - name: This runs only if there is an error in the block
        debug:
          msg: "There was an error!"
    always:
      - name: This always runs, regardless of success or failure
        debug:
          msg: "This always executes."
```

---

### **11. Performance & Optimization**

**Q106. What are some ways to improve Ansible performance?**
**A:**
*   **Enable Pipelining:** Reduces the number of SSH connections by piping scripts to the SSH session. Set `pipelining = True` in `ansible.cfg`.
*   **Use `async` and `poll`:** For long-running tasks, use `async` to fire and forget, and `poll` to check later.
*   **Disable Fact Gathering:** Set `gather_facts: no` if you don't need facts.
*   **Use `forks`:** Increase the number of parallel processes. Set `forks = 50` (or higher) in `ansible.cfg`.
*   **Use Mitogen:** A third-party plugin that drastically speeds up Ansible execution (not an official Red Hat product).
*   **Use `free` strategy:** Instead of the default `linear` strategy, the `free` strategy allows hosts to run tasks as fast as they can, without waiting for other hosts.
*   **Optimize Inventory:** Use a static inventory if possible, or an efficient dynamic inventory script.

**Q107. What is the `async` and `poll` directive used for?**
**A:** They are used to control task execution for long-running tasks.
*   `async`: The maximum allowed time in seconds for the task to complete. The task will be run in the background.
*   `poll`: How often Ansible should poll to check if the task has completed. If `poll: 0`, Ansible will start the task and not wait for it (fire and forget).
```yaml
- name: Run a long-running task asynchronously
  command: /bin/long_running_operation
  async: 3600   # Max 1 hour
  poll: 30      # Check every 30 seconds
```

**Q108. How do you configure the number of parallel processes (`forks`) in Ansible?**
**A:** You can set it in the `ansible.cfg` file:
```ini
[defaults]
forks = 50
```
Or use the `-f` or `--forks` command-line option:
```bash
ansible-playbook playbook.yml -f 50
```

**Q109. What is the difference between the `linear` and `free` strategy?**
**A:**
*   **`linear` (default):** Runs each task on all hosts in a batch, waiting for all hosts to finish the task before moving to the next one.
*   **`free`:** Allows each host to run through the playbook as fast as it can, without waiting for other hosts. This can significantly speed up playbooks on hosts with varying performance.

**Q110. What is the purpose of the `fact_caching` option?**
**A:** It caches facts gathered from hosts to avoid re-gathering them on every playbook run, which saves time. A common cache plugin is `redis` or `jsonfile`.
```ini
[defaults]
gathering = smart
fact_caching = jsonfile
fact_caching_connection = /path/to/cachedir
fact_caching_timeout = 86400 # 1 day in seconds
```

---

### **12. Ansible Tower / AWX**

**Q111. What is Ansible Tower?**
**A:** Ansible Tower (now part of the Red Hat Ansible Automation Platform) is a commercial web-based UI, dashboard, and REST API for Ansible. It provides an enterprise framework for controlling, securing, and managing Ansible automation at scale.

**Q112. What is AWX?**
**A:** AWX is the open-source upstream project for Ansible Tower. It provides a web-based interface and API for Ansible. It's where new features are developed and tested before being included in the commercial Ansible Tower product.

**Q113. What are the key features of Ansible Tower/AWX?**
**A:**
*   **Graphical User Interface (GUI):** For managing inventory, credentials, playbooks, and launching jobs.
*   **Role-Based Access Control (RBAC):** Fine-grained control over who can run what.
*   **Job Scheduling:** Run playbooks at specific times or intervals.
*   **RESTful API:** For integrating Ansible into other tools and workflows.
*   **Centralized Logging:** Audit trails of all automation jobs.
*   **Workflows:** Chain multiple playbooks and updates across different systems.

**Q114. What is a Job Template in Ansible Tower?**
**A:** A Job Template is a definition and set of parameters for running an Ansible job. It ties together a project (playbook source), an inventory, credentials, and other options like tags or limits.

**Q115. What are Inventories, Projects, and Credentials in Tower?**
**A:**
*   **Inventory:** A collection of hosts against which jobs are run (static or dynamic).
*   **Project:** A logical collection of Ansible playbooks, represented in Tower. It's usually sourced from a version control system (e.g., Git).
*   **Credentials:** Stored authentication information (SSH keys, sudo passwords, cloud access keys, etc.) used to access inventories and other systems. Tower securely encrypts these.

**Q116. How does Ansible Tower handle credentials securely?**
**A:** Tower stores credentials in an encrypted database. It never logs credentials in plaintext and can use external secret management systems like HashiCorp Vault via its credential plugins.

---

### **13. Advanced Scenarios & Best Practices**

**Q117. How would you implement a rolling update with Ansible?**
**A:** Use the `serial` keyword in a play. This defines how many hosts to update at a time.
```yaml
- name: Rolling update of web servers
  hosts: web
  serial: 2 # Update 2 hosts at a time
  tasks:
    - name: Stop service for update
      service: name=myapp state=stopped
    - name: Update application
      yum: name=myapp state=latest
    - name: Start service
      service: name=myapp state=started
```

**Q118. How can you dynamically include other playbooks or tasks based on a condition?**
**A:** Use `include_tasks` for dynamic inclusion at runtime.
```yaml
- name: Include tasks based on OS
  include_tasks: "{{ item }}"
  with_first_found:
    - "tasks/setup_{{ ansible_os_family }}.yml"
    - "tasks/setup_default.yml"
```
Or use `import_playbook` (static) to include whole playbooks.

**Q119. What are Lookup Plugins? Give an example.**
**A:** Lookup plugins are used to access data from external sources. They are used with the `lookup` keyword.
```yaml
- name: Read a file from the control node
  debug:
    msg: "{{ lookup('file', '/path/to/file.txt') }}"

- name: Get a password from the OS keyring
  debug:
    msg: "{{ lookup('community.general.keyring', 'my_service username') }}"

- name: Generate a random password
  debug:
    msg: "{{ lookup('password', '/dev/null length=15 chars=ascii_letters,digits') }}"
```

**Q120. How do you manage different environments (dev, staging, prod) with Ansible?**
**A:** Best practices include:
*   **Separate Inventories:** Have different inventory files or groups for each environment (`inventory_dev`, `inventory_prod`).
*   **Group Variables:** Use `group_vars/` directories to define environment-specific variables (e.g., `group_vars/all/prod.yml`, `group_vars/all/dev.yml`).
*   **Role Reusability:** Use the same roles across environments but feed them different variables (e.g., `web_url: dev.example.com` vs `web_url: example.com`).
*   **Vault for Secrets:** Use Ansible Vault to encrypt secrets for each environment.

**Q121. What is the purpose of the `delegate_to` keyword?**
**A:** It is used to run a task on a different host than the one being operated on. A common use case is to add a host to a load balancer. The task runs on the load balancer host, but the context (variables like `inventory_hostname`) is still the original web server.
```yaml
- name: Remove host from load balancer
  command: remove_host_from_lb {{ inventory_hostname }}
  delegate_to: load_balancer.example.com
```

**Q122. What is the `local_action` keyword used for?**
**A:** It is used to run a task on the control node itself. It is equivalent to `delegate_to: localhost`.
```yaml
- name: Create a timestamp file on the control node
  local_action:
    module: file
    path: "/tmp/deployment-{{ ansible_date_time.epoch }}.txt"
    state: touch
```

**Q123. How do you handle OS family differences in a playbook (e.g., RedHat vs. Debian)?**
**A:** Use conditionals based on the `ansible_os_family` fact.
```yaml
tasks:
  - name: Install HTTPD
    package:
      name: "{{ 'apache2' if ansible_os_family == 'Debian' else 'httpd' }}"
      state: present

  - name: Start and enable service
    service:
      name: "{{ 'apache2' if ansible_os_family == 'Debian' else 'httpd' }}"
      state: started
      enabled: yes
```

**Q124. What are some best practices for writing Ansible playbooks?**
**A:**
*   **Use Roles:** Organize your code into reusable roles.
*   **Name All Tasks:** Always use the `name` field for clarity and logging.
*   **Use State-driven Modules:** Use modules like `apt`, `yum`, `service`, `file` instead of raw `command` or `shell` for idempotency.
*   **Keep Playbooks Simple and Readable.**
*   **Use Version Control:** For all playbooks, roles, and inventories.
*   **Test with `--check` (Dry Run).**
*   **Secure Secrets with Vault.**
*   **Use `group_vars` and `host_vars`** for variable organization.
*   **Document your code** with comments and README files.

---

### **14. Ansible Galaxy & Community**

**Q125. What is Ansible Galaxy?**
**A:** Ansible Galaxy is a official hub for finding, reusing, and sharing Ansible content. It primarily provides a platform for sharing Ansible Roles.

**Q126. How do you search for a role on Ansible Galaxy from the command line?**
**A:**
```bash
ansible-galaxy role search 'elasticsearch'
```

**Q127. How do you install a role from a specific GitHub user?**
**A:**
```bash
ansible-galaxy role install git+https://github.com/username/repo_name.git
```

**Q128. What is a `requirements.yml` file used for?**
**A:** It is used to define a list of roles to be installed from various sources (Galaxy, Git, etc.) using the `ansible-galaxy install -r requirements.yml` command.
```yaml
# From Galaxy
- src: geerlingguy.nginx
  version: 2.0.0

# From GitHub
- src: https://github.com/geerlingguy/ansible-role-java
  name: java_role
  scm: git
  version: master

# From a private Git server
- src: git@github.com:my_org/private_role.git
  name: private_role
  scm: git
  version: main
```

---

### **15. DevOps & CI/CD Integration**

**Q129. How can you integrate Ansible into a CI/CD pipeline (e.g., Jenkins, GitLab CI)?**
**A:**
1.  **Source:** The pipeline is triggered by a code commit to a Git repository containing the Ansible code.
2.  **Lint/Test:** Stage to run `ansible-lint` and `ansible-playbook --syntax-check`.
3.  **Security Scan:** Stage to run a security scan on the playbooks (e.g., with `ansible-review` or general SAST tools).
4.  **Deploy to Test:** Stage to run the playbook against a test environment (`ansible-playbook -i inventory_test site.yml`).
5.  **Integration Tests:** Run automated tests to verify the deployment was successful.
6.  **Deploy to Prod:** If tests pass, a manual or automated approval gate triggers the playbook run against the production environment (`ansible-playbook -i inventory_prod site.yml --check` first, then without `--check`).

**Q130. What is `ansible-lint`?**
**A:** `ansible-lint` is a command-line tool for linting Ansible playbooks and roles. It checks for best practices, syntax errors, and potential problems, helping you write better, more reliable playbooks.

**Q131. How do you use `ansible-pull`?**
**A:** `ansible-pull` is a small script that reverses the Ansible architecture. Instead of a central control node pushing configurations, each managed node checks out a playbook repository from Git and runs `ansible-pull` locally to configure itself. It's useful for large-scale, self-healing infrastructures.
```bash
ansible-pull -U https://github.com/user/repo.git -i hosts local.yml
```

**Q132. How can you use Ansible to create infrastructure (Infrastructure as Code)?**
**A:** Ansible can be used as an IaC tool by using its cloud modules (e.g., `ec2_instance`, `azure_rm_virtualmachine`, `gcp_compute_instance`) to provision infrastructure before configuring it.
```yaml
- name: Create an EC2 instance
  community.aws.ec2_instance:
    name: "web-server"
    key_name: "my-key"
    instance_type: t3.micro
    image_id: ami-12345678
    wait: yes
    region: us-east-1
  register: ec2

- name: Add new instance to host group
  add_host:
    name: "{{ ec2.instances[0].public_ip }}"
    groups: web_just_created

- name: Configure the new instance
  hosts: web_just_created
  become: yes
  tasks:
    - name: Install Nginx
      apt: name=nginx state=present
```

This list provides a strong foundation covering fundamental concepts, practical usage, and advanced topics. Be prepared to discuss your own experiences and specific use cases from your projects.