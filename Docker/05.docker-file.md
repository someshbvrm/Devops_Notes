
---

# 🐳 Dockerfile Guide: Building Custom Images

Docker can **build images automatically** by reading instructions from a **Dockerfile**, which is a text file containing all the commands a user could call manually to assemble an image.

---

## 🔑 Key Points

* **Filename:** Must be exactly `Dockerfile` (case-sensitive, no extension).
* **Single Dockerfile per directory:** For multiple microservices, create **one directory per service**.
* **Build Images:**

```bash
# Build from current directory
docker build -t myimage:tag .

# Build from specified path
docker build -t newimage:tag /home/ubuntu/microservice/

# Build with just a name (latest tag)
docker build -t mytomcat:latest .
```

---

## 📝 Dockerfile Instructions

### Base Instructions

| Instruction | Purpose                                         |
| ----------- | ----------------------------------------------- |
| `FROM`      | Sets **base image** for subsequent instructions |
| `RUN`       | Executes commands in a new layer during build   |
| `CMD`       | Default command to run when container starts    |
| `LABEL`     | Adds metadata to the image                      |
| `EXPOSE`    | Documents container ports                       |

### Configuration Instructions

| Instruction | Purpose                                        |
| ----------- | ---------------------------------------------- |
| `ENV`       | Sets environment variables                     |
| `ARG`       | Build-time variables                           |
| `WORKDIR`   | Sets working directory                         |
| `USER`      | Switches user for subsequent commands          |
| `SHELL`     | Overrides default shell for RUN/CMD/ENTRYPOINT |

### File Operations

| Instruction | Purpose                                             |
| ----------- | --------------------------------------------------- |
| `COPY`      | Copies files/directories into container (preferred) |
| `ADD`       | Copies files/URLs and extracts archives             |

### Execution Control

| Instruction  | Purpose                                   |
| ------------ | ----------------------------------------- |
| `ENTRYPOINT` | Configures container as executable        |
| `VOLUME`     | Creates mount points for external volumes |

### Advanced Instructions

| Instruction   | Purpose                                    |
| ------------- | ------------------------------------------ |
| `ONBUILD`     | Trigger instructions for downstream builds |
| `STOPSIGNAL`  | Sets signal for stopping container         |
| `HEALTHCHECK` | Defines container health check             |

**Deprecated:** `MAINTAINER` → Use `LABEL` instead.

> 💡 **Best Practice:** Use `COPY` over `ADD` unless you specifically need `ADD`’s auto-extraction or URL support.

---

## 🏗️ Sample Apache Tomcat Dockerfile

```dockerfile
# Base image
FROM tomcat:9.0-jdk17-openjdk

# Metadata
LABEL maintainer="your.email@example.com"

# Remove default Tomcat apps (optional)
RUN rm -rf /usr/local/tomcat/webapps/ROOT*

# Copy custom configurations
COPY conf/server.xml /usr/local/tomcat/conf/
COPY conf/context.xml /usr/local/tomcat/conf/

# Deploy WAR file
COPY target/your-app.war /usr/local/tomcat/webapps/ROOT.war

# Create volume for logs and temp files
VOLUME ["/usr/local/tomcat/logs", "/usr/local/tomcat/temp"]

# Expose port
EXPOSE 8080

# Environment variables
ENV CATALINA_OPTS="-Xms512m -Xmx1024m"

# Healthcheck
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:8080/ || exit 1

# Start Tomcat
CMD ["catalina.sh", "run"]
```

**Build & Run:**

```bash
docker build -t my-tomcat-app .
docker run -d -p 8080:8080 --name tomcat-container my-tomcat-app
```

> Tutorial Reference: [Docker Tomcat Example](https://www.middlewareinventory.com/blog/docker-tomcat-example-dockerfile-sample/)

---

## ⚡ Multi-Service Projects

Your project may contain:

* **Frontend:** ReactJS / Angular
* **Backend:** Spring Boot / NodeJS / .NET / Python
* **Python Frameworks:** Django / Flask

---

## 🟢 Spring Boot Dockerfile

```dockerfile
FROM openjdk:8-jdk-alpine
LABEL maintainer="info@cloudsoftsol.com"

# Copy JAR
COPY target/docker-message-server-1.0.0.jar message-server-1.0.0.jar

# Run Spring Boot app
ENTRYPOINT ["java","-jar","/message-server-1.0.0.jar"]
```

---

## 🟢 Node.js Dockerfile

```dockerfile
# Working directory
WORKDIR /usr/src/app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy app source
COPY . .

# Expose port
EXPOSE 8080

# Start app
CMD ["node", "server.js"]
```

**Build & Run**

```bash
docker build -t node-app .
docker run -p 8080:8080 node-app
```

> **COPY . . Explanation:**
>
> * First `.` → Local directory (build context)
> * Second `.` → Container working directory (e.g., `/usr/src/app`)

---

## 🟢 Python Dockerfile

```dockerfile
# Base image
FROM python:3.9-slim

# Working directory
WORKDIR /app

# Install dependencies
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY src/ . 

# Expose port
EXPOSE 8080

# Run application
CMD ["python", "server.py"]
```

**Build & Run**

```bash
docker build -t python-app .
docker run -p 8080:8080 python-app
```

---

✅ This structure ensures **layer caching, readability, and portability** while maintaining your original concepts.

---
