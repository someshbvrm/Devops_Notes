
---
# Git Interview Question and Answers

### **Table of Contents**
1.  **Git Fundamentals & Core Concepts**
2.  **Installation, Setup, & Configuration**
3.  **Basic Commands & Local Repository**
4.  **Branching & Merging**
5.  **Remote Repositories (GitHub, GitLab, etc.)**
6.  **Undoing Changes & Rewriting History**
7.  **Stashing & Cleaning**
8.  **Tagging**
9.  **Debugging & Introspection**
10. **Advanced Git Concepts**
11. **Workflows & Best Practices**
12. **Submodules & Subtrees**
13. **Hooks & Automation**
14. **CI/CD Integration & DevOps**
15. **Scenario-Based & Problem-Solving Questions**

---

### **1. Git Fundamentals & Core Concepts**

**Q1. What is Git?**
**A:** Git is a free, open-source Distributed Version Control System (DVCS) designed to handle everything from small to very large projects with speed and efficiency. It tracks changes in source code, enabling multiple developers to work together on non-linear development.

**Q2. What is a Version Control System (VCS)?**
**A:** A VCS is a system that records changes to a file or set of files over time so that you can recall specific versions later. It allows you to revert files to a previous state, compare changes over time, see who last modified something, and more.

**Q3. What is the difference between Centralized VCS (CVCS) and Distributed VCS (DVCS)?**
**A:**
*   **CVCS (e.g., SVN, CVS):** Has a single central server that stores all the version history. Developers check out files from this central server. This is a single point of failure.
*   **DVCS (e.g., Git, Mercurial):** Every developer's working copy of the code is also a complete repository with full history. They can work offline and sync with any other copy later. There is no single point of failure.

**Q4. What is a Git repository?**
**A:** A Git repository (or repo) is a storage location where Git stores all the files and the complete history of changes for a project. It is contained in a `.git` folder in the project's root directory.

**Q5. What are the four fundamental states of a file in Git?**
**A:**
1.  **Untracked:** The file exists in the working directory but is not yet part of Git's version control.
2.  **Modified:** The file has been changed in the working directory but is not yet staged.
3.  **Staged:** The modified file has been marked to be included in the next commit snapshot (in the staging area/index).
4.  **Committed:** The file is safely stored in the local repository (.git directory).

**Q6. What are the three main sections of a Git project?**
**A:**
1.  **Working Directory:** The local directory on your machine where you make changes to files.
2.  **Staging Area (Index):** A file, generally contained in the `.git` directory, that stores information about what will go into your next commit. It's a preview of the next commit.
3.  **Git Directory (Repository):** The `.git` folder where Git stores the metadata and object database for your project. This is what gets cloned.

**Q7. What is a `commit` in Git?**
**A:** A commit is a snapshot of your project's staged changes at a point in time. It is permanently stored in the repository's history. Each commit has a unique SHA-1 hash identifier.

**Q8. What is a `SHA-1 hash` in the context of Git?**
**A:** It is a 40-character checksum hash generated based on the contents of a commit (changes, author, date, message, previous commit). It serves as a unique ID for each commit (e.g., `e3d4a19c8c83e7aab5b1c3d7d1e3a4b5c7d9e1f2`). Git uses this to ensure data integrity.

**Q9. What is the `HEAD` pointer in Git?**
**A:** `HEAD` is a symbolic reference that points to the current branch reference, which in turn points to the latest commit on that branch. It essentially represents your current working location in the repository's history. You can think of it as "you are here."

**Q10. What is the difference between `git` and GitHub?**
**A:** Git is the version control *tool* itself—the software that runs on your computer. GitHub is a commercial web-based *hosting service* for Git repositories. It provides a GUI, collaboration features like pull requests and issue tracking, and is a central place to share Git repositories. Other alternatives are GitLab and Bitbucket.

---

### **2. Installation, Setup, & Configuration**

**Q11. How do you install Git on a Ubuntu machine?**
**A:**
```bash
sudo apt update
sudo apt install git
```

**Q12. How do you check the version of Git installed?**
**A:**
```bash
git --version
```

**Q13. What is the first thing you should do after installing Git?**
**A:** Configure your user name and email address. This information is attached to your commits.
```bash
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
```

**Q14. What are the three levels of Git configuration and their precedence?**
**A:** From highest to lowest precedence:
1.  **Local (`--local`):** Specific to a single repository (stored in `.git/config`).
2.  **Global (`--global`):** Specific to the user (stored in `~/.gitconfig` or `~/.config/git/config`).
3.  **System (`--system`):** For all users on the system (stored in `/etc/gitconfig`).

**Q15. How do you list all your current Git configurations?**
**A:**
```bash
git config --list
```

**Q16. How do you set your default text editor for Git to Vim?**
**A:**
```bash
git config --global core.editor "vim"
```

**Q17. How do you set the default branch name for new repositories to `main`?**
**A:**
```bash
git config --global init.defaultBranch main
```

**Q18. How do you enable colorful output in the Git command line?**
**A:**
```bash
git config --global color.ui auto
```

**Q19. How do you create an alias `git co` for `git checkout`?**
**A:**
```bash
git config --global alias.co checkout
```

**Q20. How do you check your global Git configuration?**
**A:**
```bash
cat ~/.gitconfig
# or
git config --global --list
```

---

### **3. Basic Commands & Local Repository**

**Q21. How do you initialize a new Git repository?**
**A:**
```bash
git init
```
This creates a `.git` subdirectory.

**Q22. How do you clone an existing repository?**
**A:**
```bash
git clone <repository-url>
# e.g., git clone https://github.com/user/repo.git
# To clone into a specific directory:
git clone <repository-url> <directory-name>
```

**Q23. How do you check the status of your working directory?**
**A:**
```bash
git status
```

**Q24. How do you add a specific file to the staging area?**
**A:**
```bash
git add filename.txt
```

**Q25. How do you add all changed files to the staging area?**
**A:**
```bash
git add .
# or to add all files, including untracked (be careful!)
git add -A
```

**Q26. How do you commit the staged changes?**
**A:**
```bash
git commit -m "Your descriptive commit message"
```

**Q27. How do you commit and skip the staging area (stage all tracked files and commit)?**
**A:** *Use with caution, as it can include unintended changes.*
```bash
git commit -a -m "Your message"
```

**Q28. How do you view the commit history?**
**A:**
```bash
git log
```

**Q29. How do you make `git log` show a more concise, graph-like output?**
**A:**
```bash
git log --oneline --graph --all
```

**Q30. How do you see the differences between your working directory and the staging area?**
**A:**
```bash
git diff
```

**Q31. How do you see the differences between the staging area and the last commit?**
**A:**
```bash
git diff --staged
# or
git diff --cached
```

**Q32. How do you remove a file from Git and the working directory?**
**A:**
```bash
git rm filename.txt
```

**Q33. How do you remove a file from Git but keep it in your working directory?**
**A:**
```bash
git rm --cached filename.txt
# The file becomes untracked.
```

**Q34. How do you move or rename a file in Git?**
**A:**
```bash
git mv oldname.txt newname.txt
```

**Q35. How do you ignore files in Git?**
**A:** Create a file called `.gitignore` in the root of your repository. Inside it, list patterns of files/directories to ignore (e.g., `*.log`, `node_modules/`, `.env`).

**Q36. What does the `.gitignore` file do?**
**A:** It tells Git which files and directories to ignore and not track. This is typically used for build artifacts, logs, local configuration files, and dependencies.

**Q37. How do you see the contents of a specific commit?**
**A:**
```bash
git show <commit-hash>
```

**Q38. What is the purpose of `git blame`?**
**A:** It shows what revision and author last modified each line of a file. It's useful for tracing changes and identifying who introduced a specific line of code.
```bash
git blame filename.txt
```

**Q39. What is `git grep` used for?**
**A:** It allows you to search through your working directory or any tree for a specific string or regular expression.
```bash
git grep "search term"
```

---

### **4. Branching & Merging**

**Q40. What is a branch in Git?**
**A:** A branch is a lightweight, movable pointer to a specific commit. It allows you to isolate development work without affecting other branches. The default branch is usually `main` or `master`.

**Q41. How do you list all branches?**
**A:**
```bash
git branch      # Lists local branches
git branch -r   # Lists remote tracking branches
git branch -a   # Lists all local and remote branches
```

**Q42. How do you create a new branch?**
**A:**
```bash
git branch new-feature
```

**Q43. How do you create a new branch and switch to it immediately?**
**A:**
```bash
git checkout -b new-feature
# In newer versions of Git, you can also use:
git switch -c new-feature
```

**Q44. How do you switch to an existing branch?**
**A:**
```bash
git checkout branch-name
# or
git switch branch-name
```

**Q45. How do you delete a branch?**
**A:**
```bash
git branch -d branch-name  # Safe delete (checks for merge)
git branch -D branch-name  # Force delete (even if unmerged)
```

**Q46. What is the difference between `git checkout` and `git switch`/`git restore`?**
**A:** `git checkout` was a overloaded command used for switching branches *and* restoring files. The commands were split for clarity:
*   `git switch`: Used for switching branches.
*   `git restore`: Used for restoring files in the working directory or staging area.

**Q47. What is a `fast-forward` merge?**
**A:** A fast-forward merge is possible when the target branch's tip is a direct ancestor of the source branch. Instead of creating a new merge commit, Git simply moves the branch pointer forward along the line of history.

**Q48. How do you perform a merge?**
**A:** First, switch to the branch you want to merge *into* (e.g., `main`). Then merge the other branch.
```bash
git checkout main
git merge new-feature
```

**Q49. How do you perform a merge and always create a merge commit, even if it's a fast-forward?**
**A:**
```bash
git merge --no-ff new-feature
```

**Q50. What is a merge conflict?**
**A:** A merge conflict occurs when Git cannot automatically resolve differences in code between two commits. This happens when the same part of the same file has been changed in both branches.

**Q51. How do you identify files with merge conflicts?**
**A:** `git status` will show them as "Unmerged paths."

**Q52. How do you resolve a merge conflict?**
**A:**
1.  Open the conflicted file(s). Git marks the conflicts with `<<<<<<<`, `=======`, and `>>>>>>>`.
2.  Edit the file to choose which changes to keep. Remove the conflict markers.
3.  Stage the resolved file: `git add filename.txt`.
4.  Commit the resolution: `git commit`.

**Q53. What is rebasing?**
**A:** Rebasing is the process of moving or combining a sequence of commits to a new base commit. It effectively replays your changes on top of another branch, creating a linear history.

**Q54. How do you rebase your current branch onto another branch?**
**A:**
```bash
git checkout feature-branch
git rebase main
```

**Q55. What is the difference between merging and rebasing?**
**A:**
*   **Merge:** Preserves the entire history exactly as it happened. Creates a new merge commit. History is non-linear (shows forks).
*   **Rebase:** Rewrites history by creating new commits. Results in a cleaner, linear history. *Never rebase commits that have been pushed to a public repository.*

**Q56. What is an interactive rebase?**
**A:** Interactive rebasing (`git rebase -i`) allows you to alter commits as they are moved to the new base. You can squash commits, reword messages, edit commits, or drop them entirely.

**Q57. How do you squash the last N commits together using interactive rebase?**
**A:**
```bash
git rebase -i HEAD~N
# Then change the words 'pick' to 'squash' (or 's') for the commits you want to squash into the one above them.
```

**Q58. What is a detached HEAD state?**
**A:** A detached HEAD occurs when you check out a specific commit, tag, or remote branch directly, instead of a local branch name. Your working directory matches the state of that specific commit, but you are not on any branch. Any commits made here will be lost unless you create a new branch pointer to them.

---

### **5. Remote Repositories (GitHub, GitLab, etc.)**

**Q59. What is a remote in Git?**
**A:** A remote is a common repository on a server (like GitHub) that all team members use to exchange their changes. It's a pointer to another copy of the repository.

**Q60. How do you view the list of remotes for a repository?**
**A:**
```bash
git remote -v  # The -v flag shows the URLs
```

**Q61. How do you add a new remote named `origin`?**
**A:**
```bash
git remote add origin <repository-url>
# e.g., git remote add origin https://github.com/user/repo.git
```

**Q62. How do you rename a remote?**
**A:**
```bash
git remote rename old-name new-name
```

**Q63. How do you remove a remote?**
**A:**
```bash
git remote remove remote-name
```

**Q64. How do you download changes from a remote repository without merging them?**
**A:**
```bash
git fetch origin
```

**Q65. What is the difference between `git fetch` and `git pull`?**
**A:**
*   **`git fetch`** downloads the latest changes from the remote but does not integrate them into your working files. It updates your remote-tracking branches (e.g., `origin/main`).
*   **`git pull`** is a combination of `git fetch` followed by `git merge`. It fetches the changes and immediately merges them into your current branch.

**Q66. How do you pull changes with rebase instead of merge?**
**A:**
```bash
git pull --rebase
```

**Q67. How do you push your local branch to a remote repository?**
**A:**
```bash
git push origin branch-name
```

**Q68. How do you push a new local branch to the remote and set upstream tracking?**
**A:**
```bash
git push -u origin branch-name
# The -u (--set-upstream) flag sets the tracking reference.
```

**Q69. What does `git push` do without any arguments?**
**A:** It pushes the current branch to its upstream remote branch, but only if the upstream branch already exists and has the same name. If not configured, it will fail.

**Q70. How do you delete a branch on the remote repository?**
**A:**
```bash
git push origin --delete branch-name
# or
git push origin :branch-name  # Older syntax
```

**Q71. What is a fork?**
**A:** A fork is a personal copy of another user's repository on a Git hosting service like GitHub. It allows you to freely experiment with changes without affecting the original project.

**Q72. What is a Pull Request (PR) or Merge Request (MR)?**
**A:** A Pull Request is a mechanism on Git hosting platforms to propose changes from a fork or branch. It lets you notify others about the changes you've pushed, discuss them, and request that they review and merge your code into the main branch.

**Q73. What is an `upstream` remote?**
**A:** In the context of a forked repository, the `origin` remote typically points to your fork. The `upstream` remote is a convention for pointing to the original repository you forked from. This allows you to sync your fork with the latest changes from the original project.
```bash
git remote add upstream https://github.com/original-owner/repo.git
```

**Q74. How do you sync your forked repository with the upstream repository?**
**A:**
```bash
git fetch upstream
git checkout main
git merge upstream/main
git push origin main # Push the updated main to your fork
```

**Q75. What is a `remote-tracking branch` (e.g., `origin/main`)?**
**A:** It is a local reference to the state of a branch on a remote repository. You cannot commit to it directly. It's updated when you run `git fetch` or `git pull`.

---

### **6. Undoing Changes & Rewriting History**

**Q76. How do you undo changes in your working directory for a specific file?**
**A:**
```bash
git restore filename.txt
# or (older command)
git checkout -- filename.txt
```

**Q77. How do you unstage a file that you have added to the staging area?**
**A:**
```bash
git restore --staged filename.txt
# or
git reset HEAD filename.txt  # Older command
```

**Q78. How do you amend the most recent commit?**
**A:** This changes the commit history and should be done only on local, unpushed commits.
```bash
# Stage any new changes you want to include, then:
git commit --amend
# This opens your editor to also let you change the commit message.
```

**Q79. How do you revert a specific commit by creating a new commit that undoes the changes?**
**A:** This is safe for public history.
```bash
git revert <commit-hash>
```

**Q80. What is the difference between `git revert` and `git reset`?**
**A:**
*   **`git revert`** undoes a commit by creating a *new* commit that inverses the changes. It is safe for public commits as it doesn't rewrite shared history.
*   **`git reset`** moves the *current branch pointer* backwards to a previous commit, effectively erasing commits from the current branch's history. It is dangerous for commits that have been pushed because it rewrites history.

**Q81. What are the different modes of `git reset`?**
**A:**
*   **`--soft`:** Moves HEAD to the target commit. Staging area and working directory are untouched. Changes from "erased" commits appear staged.
*   **`--mixed` (default):** Moves HEAD and updates the staging area to match the target commit. Changes from "erased" commits appear as unstaged modifications in the working directory.
*   **`--hard`:** **Dangerous.** Moves HEAD, updates staging area, *and* updates working directory to match the target commit. All changes since the target commit are permanently lost.

**Q82. How do you reset your current branch to match the remote repository? (Discard all local changes)**
**A:**
```bash
git fetch origin
git reset --hard origin/main  # Be extremely careful! This destroys work.
```

**Q83. How do you remove a file from the last commit without changing the commit message?**
**A:**
```bash
git rm --cached filename.txt
git commit --amend
```

**Q84. What is the `git reflog` and how can it save you?**
**A:** The reference log (`reflog`) is a log of where your HEAD and branch references have been for the last few months. It allows you to go back to commits even after you've done a `reset --hard` or deleted a branch, as long as the objects haven't been garbage collected yet.
```bash
git reflog
# Then reset to a specific entry
git reset --hard HEAD@{5}
```

---

### **7. Stashing & Cleaning**

**Q85. What is `git stash`?**
**A:** `git stash` temporarily shelves (or stashes) changes you've made to your working directory so you can work on something else, and then come back and re-apply them later.

**Q86. How do you stash your current changes?**
**A:**
```bash
git stash
# To include untracked files:
git stash -u
```

**Q87. How do you list all stashes?**
**A:**
```bash
git stash list
```

**Q88. How do you apply the most recent stash and keep it in the stash list?**
**A:**
```bash
git stash apply
```

**Q89. How do you apply a specific stash from the list?**
**A:**
```bash
git stash apply stash@{2}
```

**Q90. How do you apply a stash and remove it from the stash list?**
**A:**
```bash
git stash pop  # Applies and drops the top stash
git stash pop stash@{2} # Applies and drops a specific stash
```

**Q91. How do you delete a stash?**
**A:**
```bash
git stash drop stash@{1}
# To delete all stashes:
git stash clear
```

**Q92. How do you create a branch from a stash?**
**A:**
```bash
git stash branch new-branch-name stash@{1}
```

**Q93. What is the difference between `git stash pop` and `git stash apply`?**
**A:** `apply` applies the changes but keeps the stash in the list. `pop` applies the changes and immediately drops (deletes) the stash from the list.

**Q94. What does `git clean` do?**
**A:** It removes untracked files from the working directory. *Use with extreme caution, as this operation cannot be undone.*

**Q95. How do you do a dry run of `git clean` to see what would be removed?**
**A:**
```bash
git clean -n  # or --dry-run
```

**Q96. How do you remove untracked files and directories?**
**A:**
```bash
git clean -f  # Remove files
git clean -fd # Remove files and directories
git clean -fdx # Remove ignored files as well
```

---

### **8. Tagging**

**Q97. What is a tag in Git?**
**A:** A tag is a static, immutable reference to a specific commit. It is typically used to mark release points (e.g., v1.0.0).

**Q98. What is the difference between a lightweight tag and an annotated tag?**
**A:**
*   **Lightweight Tag:** Just a pointer to a specific commit, like a branch that doesn't change. It doesn't store extra information.
*   **Annotated Tag:** Stored as a full object in the Git database. They are checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed for verification. *Always prefer annotated tags for public releases.*

**Q99. How do you create an annotated tag?**
**A:**
```bash
git tag -a v1.0.0 -m "Release version 1.0.0"
```

**Q100. How do you create a lightweight tag?**
**A:**
```bash
git tag v1.0.0-lw
```

**Q101. How do you list all tags?**
**A:**
```bash
git tag
```

**Q102. How do you push a specific tag to the remote?**
**A:**
```bash
git push origin v1.0.0
```

**Q103. How do you push all tags to the remote?**
**A:**
```bash
git push origin --tags
```

**Q104. How do you delete a local tag?**
**A:**
```bash
git tag -d v1.0.0
```

**Q105. How do you delete a remote tag?**
**A:**
```bash
git push origin --delete v1.0.0
# or
git push origin :refs/tags/v1.0.0
```

**Q106. How do you check out a specific tag?**
**A:** This puts you in a detached HEAD state.
```bash
git checkout v1.0.0
```

---

### **9. Debugging & Introspection**

**Q107. How do you use `git bisect` to find a bug?**
**A:** `git bisect` performs a binary search through your history to find the commit that introduced a bug.
1.  Start the process: `git bisect start`
2.  Mark a known bad commit (e.g., HEAD): `git bisect bad`
3.  Mark a known good commit (e.g., an old tag): `git bisect good v1.0`
4.  Git will checkout a commit. Test your code.
5.  Tell Git the result: `git bisect good` or `git bisect bad`.
6.  Repeat step 4-5 until Git identifies the first bad commit.
7.  Reset when done: `git bisect reset`

**Q108. How do you see what was changed in a specific commit?**
**A:**
```bash
git show <commit-hash>
```

**Q109. How do you see the history of changes for a specific file?**
**A:**
```bash
git log --follow -p filename.txt
# --follow follows renames, -p shows the diff
```

**Q110. What does `git cherry-pick` do?**
**A:** It applies the changes introduced by an existing commit onto your current branch. It's useful for porting a single commit from one branch to another.
```bash
git cherry-pick <commit-hash>
```

---

### **10. Advanced Git Concepts**

**Q111. What is the Git object model? What are the main object types?**
**A:** Git's database is a content-addressable storage system for key-value pairs. The main objects are:
*   **Blobs:** Store file data.
*   **Trees:** Represent directories; contain blobs and other trees.
*   **Commits:** Point to a tree (project snapshot), parent commit(s), and contain metadata (author, message).
*   **Tags:** Point to a specific commit.

**Q112. What is the purpose of `git fsck`?**
**A:** It verifies the integrity of the Git file system and object database, checking for corrupt objects.

**Q113. What is `git gc` (Garbage Collection) used for?**
**A:** It cleans up unnecessary files and optimizes the local repository. It removes loose objects, packs refs, and prunes unreachable objects.

**Q114. What is a "bare repository"?**
**A:** A bare repository is one that does not have a working directory—it only contains the `.git` directory contents. It is used as a central shared repository (like on a server) where developers push their code. You create one with `git init --bare`.

**Q115. What are `git hooks`?**
**A:** Hooks are scripts that run automatically before or after specific Git commands (e.g., `pre-commit`, `post-receive`). They are stored in the `.git/hooks/` directory.

**Q116. What is the Git Worktree feature?**
**A:** It allows you to have multiple working directories attached to the same repository. This lets you work on multiple branches simultaneously without stashing.
```bash
git worktree add ../new-directory feature-branch
```

**Q117. What is a `.gitattributes` file used for?**
**A:** It defines attributes for paths, such as:
*   Specifying merge strategies for files.
*   Telling Git to diff binary files.
*   Exporting/importing files via `git archive`.
*   Defining which files should be treated as binary vs. text.

**Q118. How can you make Git treat a file as binary to avoid diffs?**
**A:** In `.gitattributes`:
```
*.pdf binary
```

**Q119. What is `git submodule`?**
**A:** A submodule lets you keep another Git repository in a subdirectory of your repository. It's a pointer to a specific commit in the other repository.

**Q120. What is the difference between `git submodule` and `git subtree`?**
**A:**
*   **Submodule:** A link to another repository. The code is not included in the main repo's commit. Requires extra steps to update and can be complex.
*   **Subtree:** Merges the external project's code into a subdirectory of your main repository. The code is part of the main repo's history. Simpler to use but makes the repository larger.

---

### **11. Workflows & Best Practices**

**Q121. What is a Git workflow?**
**A:** A Git workflow is a recipe or recommendation for how to use Git to accomplish work in a consistent and productive manner. Common ones include Feature Branch Workflow, Gitflow, Forking Workflow, and Trunk-Based Development.

**Q122. Describe the Feature Branch Workflow.**
**A:** All feature development is done in dedicated branches instead of the main branch. This isolates work. Developers push branches to the remote and create pull requests to merge them into main.

**Q123. Describe the Gitflow Workflow.**
**A:** A more structured workflow with specific branching roles:
*   `main`: Production code.
*   `develop`: Integration branch for features.
*   `feature/*`: Branched from `develop` for new features.
*   `release/*`: Branched from `develop` to prepare a release.
*   `hotfix/*`: Branched from `main` for urgent production fixes.

**Q124. What is Trunk-Based Development?**
**A:** Developers work on small, incremental changes and merge them into a single main branch (`trunk`) frequently, often multiple times a day. It relies heavily on feature flags and requires high-quality CI/CD.

**Q125. What is a good Git commit message practice?**
**A:** Follow a convention like:
*   **Separate subject from body with a blank line.**
*   **Limit the subject line to 50 characters.**
*   **Capitalize the subject line.**
*   **Do not end the subject line with a period.**
*   **Use the imperative mood in the subject line** (e.g., "Fix bug" not "Fixed bug" or "Fixes bug").
*   **Wrap the body at 72 characters.**
*   **Use the body to explain *what* and *why* vs. *how* (the code shows how).**

Example:
```
Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters. Be sure to explain the problem that this commit is
solving, not just what you did. Bullet points are okay.

- Point 1
- Point 2

Resolves: #12345
```

**Q126. Why is it a bad practice to commit large files or binaries to Git?**
**A:** Git is designed for tracking text-based source code, not large binaries. Committing large files:
*   **Drastically increases repository size** for every developer.
*   **Slows down** cloning, fetching, and other operations.
*   **Is hard to remove** from history once committed.
*   Use Git LFS (Large File Storage) or a dedicated artifact repository instead.

**Q127. What is Git LFS?**
**A:** Git Large File Storage (LFS) is a Git extension that replaces large files (e.g., videos, datasets, binaries) with text pointers inside Git, while storing the actual file contents on a remote server. This keeps your repository size manageable.

**Q128. What does "atomic commit" mean in Git?**
**A:** An atomic operation in Git is one that either happens completely or not at all. A Git commit is atomic—it creates a single snapshot of the entire project. You will never have a repository in a state where only half the changes from a commit are present.

**Q129. What is a "dirty" working tree?**
**A:** A working tree is considered "dirty" if it contains any uncommitted changes (modified, staged, or untracked files). Many Git commands (like `git pull` with rebase, or `git switch`) will refuse to work on a dirty tree to prevent you from losing work.

**Q130. How can you see a short, one-line status of your working tree?**
**A:**
```bash
git status -sb  # -s for short, -b for branch info
```

---

### **12. Submodules & Subtrees**

**Q131. How do you add a Git repository as a submodule?**
**A:**
```bash
git submodule add <repository-url> path/to/submodule
# e.g., git submodule add https://github.com/lib/lib.git libs/mylib
```

**Q132. After cloning a repository that contains submodules, what extra step is required?**
**A:** You must initialize and update the submodules.
```bash
git submodule init   # Registers the submodules in .gitmodules
git submodule update # Clones the submodule repositories and checks out the commit
# Or clone and initialize in one step:
git clone --recurse-submodules <repository-url>
```

**Q133. How do you update a submodule to its latest commit?**
**A:**
1.  Navigate into the submodule directory: `cd path/to/submodule`
2.  Checkout the desired branch (e.g., `main`): `git checkout main`
3.  Pull the latest changes: `git pull`
4.  Go back to the root project: `cd ../..`
5.  Stage the submodule change: `git add path/to/submodule`
6.  Commit the updated submodule pointer: `git commit -m "Update submodule"`

**Q134. What is the main disadvantage of using submodules?**
**A:** Added complexity. Developers must know about the `submodule` commands. It's easy to end up with a repository that points to a broken submodule commit if the process isn't followed carefully.

**Q135. How do you remove a submodule?** (A complex process)
**A:**
1.  `git submodule deinit -f path/to/submodule`
2.  `rm -rf .git/modules/path/to/submodule`
3.  `git rm -f path/to/submodule`

**Q136. How do you add a remote repository using `git subtree`?**
**A:** First, add the remote:
```bash
git remote add lib-remote https://github.com/lib/lib.git
```
Then, add the subtree:
```bash
git subtree add --prefix=libs/mylib lib-remote main --squash
# --prefix specifies the directory, --squash merges the entire history of the other project into a single commit.
```

**Q137. How do you pull updates from the upstream repository using `git subtree`?**
**A:**
```bash
git subtree pull --prefix=libs/mylib lib-remote main --squash
```

**Q138. What is the key advantage of `git subtree` over `git submodule`?**
**A:** The code is part of the main repository's history. This simplifies the workflow for other developers—they don't need to know about the subtree to get the code. It's just there after a clone.

---

### **13. Hooks & Automation**

**Q139. Where are Git hooks located?**
**A:** In the `.git/hooks/` directory of every Git repository.

**Q140. Name some common Git hooks and their purposes.**
**A:**
*   `pre-commit`: Runs before a commit is created. Used for linting, running tests, checking for secrets.
*   `prepare-commit-msg`: Lets you edit the default commit message before the editor is launched.
*   `commit-msg`: Can validate the project's commit message format.
*   `post-commit`: Runs after the commit process is completed. Used for notification.
*   `pre-push`: Runs before a `git push`. Used to run full test suites.
*   `post-receive`: Runs on the remote repository after a push is completed. Used for deployment.

**Q141. How can you make a hook script executable?**
**A:**
```bash
chmod +x .git/hooks/pre-commit
```

**Q142. What language are Git hooks typically written in?**
**A:** They can be written in any scripting language (Bash, Python, Ruby, etc.), as long as the script has a proper shebang line (e.g., `#!/bin/bash`) and is executable.

**Q143. How can you share hooks with your team?**
**A:** You cannot share hooks via Git itself (the `.git/hooks/` directory is not tracked). The common practice is to store your hooks in a different directory within the project (e.g., `git-hooks/`) and have developers symlink them or copy them to their `.git/hooks/` directory. Tools like Husky are popular in the JavaScript ecosystem for this.

**Q144. What does a simple `pre-commit` hook look like that prevents committing directly to the `main` branch?**
**A:**
```bash
#!/bin/sh

branch="$(git rev-parse --abbrev-ref HEAD)"

if [ "$branch" = "main" ]; then
  echo "You can't commit directly to the main branch. Use a feature branch and a PR."
  exit 1
fi
```

---

### **14. CI/CD Integration & DevOps**

**Q145. How is Git typically used in a CI/CD pipeline?**
**A:** The CI/CD system (e.g., Jenkins, GitLab CI, GitHub Actions) is triggered by a Git event (a push or a pull request). It clones the repository, checks out the specific commit that triggered the event, and then runs scripts defined in a config file (e.g., `.gitlab-ci.yml`, `.github/workflows/main.yml`) to build, test, and deploy the code.

**Q146. What is the significance of the `.gitignore` file in CI/CD?**
**A:** It ensures that build artifacts, local configuration, and dependencies from a developer's machine are not accidentally committed and then used in the clean CI/CD environment, which could cause inconsistent and failed builds.

**Q147. What is a common pattern for versioning with Git in CI/CD?**
**A:** Using Git tags to trigger production deployments. For example, pushing a tag like `v1.2.3` could automatically trigger the pipeline to build and deploy that exact version to production.

**Q148. How can you securely manage secrets (API keys, passwords) for use in CI/CD without storing them in Git?**
**A:** Use the secret management system provided by your CI/CD platform (e.g., GitHub Secrets, GitLab CI Variables). These are stored encrypted and are only exposed as environment variables in the pipeline runtime, not in the repository history.

**Q149. What is the purpose of a `Dockerfile` in a Git repository for CI/CD?**
**A:** The `Dockerfile` defines a consistent, reproducible environment for building and running the application. The CI/CD pipeline can use this file to build a container image, ensuring that the application runs the same way in development, testing, and production.

**Q150. What does the "CD" part (Continuous Deployment) often rely on in terms of Git branches?**
**A:** It often relies on the `main` or `production` branch being always deployable. The practice of Trunk-Based Development, where small changes are continuously merged into `main`, enables true continuous deployment where every commit that passes the pipeline is automatically deployed to production.

---

### **15. Scenario-Based & Problem-Solving Questions**

**Q151. You accidentally committed a large file. You've already pushed the commit. How do you remove it from history?**
**A:** **Warning: This rewrites history.** You should only do this if you are sure no one else has based work on the commits you are rewriting.
1.  Use the BFG Repo-Cleaner tool (`bfg --delete-files large_file.zip`) or `git filter-branch`.
2.  Force push the corrected history: `git push --force`.
3.  Inform all team members to rebase their work on the new history.

**Q152. You started working on a feature but need to switch to a hotfix branch. Your current changes are not ready to commit. What do you do?**
**A:** Use `git stash` to temporarily shelve your changes.
```bash
git stash -u  # -u to also stash untracked files
git switch hotfix-branch
# ... fix the issue ...
git switch feature-branch
git stash pop
```

**Q153. You made a commit to the wrong branch. How do you move it to the correct branch?**
**A:**
1.  Switch to the correct branch: `git switch correct-branch`
2.  Cherry-pick the commit: `git cherry-pick <commit-hash>`
3.  Switch back to the original branch: `git switch original-branch`
4.  Remove the commit (if it hasn't been pushed yet): `git reset --hard HEAD~1`

**Q154. Your `git pull` resulted in a merge conflict. You want to abort and start over. How?**
**A:**
```bash
git merge --abort      # If it was a merge
git rebase --abort     # If it was a rebase
```

**Q155. You want to see all branches that have been merged into your current branch.**
**A:**
```bash
git branch --merged
```

**Q156. You want to see all branches that have NOT been merged into your current branch.**
**A:**
```bash
git branch --no-merged
```

**Q157. How do you find which commit introduced a specific bug using a binary search?**
**A:** Use `git bisect`. (As described in Q107).

**Q158. You need to find a specific string that was removed in a previous commit. How?**
**A:** Use `git log -S"string"` to search the commit history for changes that added or removed that specific string.
```bash
git log -S"some variable name" --oneline
```

**Q159. You want to see the last N commits from a specific author.**
**A:**
```bash
git log -n 10 --author="John Doe"
```

**Q160. How do you create a new branch that tracks a remote branch?**
**A:** The standard way creates a tracking branch:
```bash
git checkout -b feature-branch origin/feature-branch
# or simpler, if the remote branch exists:
git switch feature-branch
# Git will automatically see the remote branch and create a tracking local branch.
```

**Q161. Your local branch has diverged from the remote branch. You want to make your local branch match the remote exactly, discarding all local changes. How?**
**A:** **This is destructive.**
```bash
git fetch origin
git reset --hard origin/main # Replace 'main' with your branch name
```

**Q162. You want to see a visual representation of your branch history.**
**A:**
```bash
git log --oneline --graph --all --decorate
```

**Q163. You want to see the differences between two branches.**
**A:**
```bash
git diff branch1..branch2
```

**Q164. You want to see the commits that are in branchA but not in branchB.**
**A:**
```bash
git log branchB..branchA
```

**Q165. How do you make Git case-sensitive?**
**A:** Git is typically case-preserving but case-insensitive. To make it sensitive, you can use:
```bash
git config core.ignorecase false
# But this can cause issues. It's better to rename files properly with `git mv`.
```

**Q166. You renamed a file using `mv` instead of `git mv`. How do you fix it?**
**A:** Stage the deletion of the old filename and the addition of the new filename. Git is usually smart enough to detect it as a rename.
```bash
git add -A
# or
git add oldname.txt newname.txt
```

**Q167. How do you see the history of a specific function or block of code?**
**A:** Use `git log -L` to show the history of a range of lines.
```bash
git log -L :function_name:file.txt
```

**Q168. You want to run a command for every commit in a range, like running a test. How?**
**A:** Use `git rebase -x` to execute a command during an interactive rebase.
```bash
git rebase -i --exec "make test" HEAD~5
```

**Q169. How do you create a patch file from a commit?**
**A:**
```bash
git format-patch -1 <commit-hash>  # Creates a .patch file for one commit
git format-patch HEAD~3..HEAD      # Creates patches for the last 3 commits
```

**Q170. How do you apply a patch file?**
**A:**
```bash
git apply patchfile.patch
# or, if created with format-patch, which includes commit info:
git am patchfile.patch
```

This list provides a strong foundation covering fundamental concepts, practical usage, and advanced scenarios. Be prepared to discuss your own experiences and specific use cases from your projects.