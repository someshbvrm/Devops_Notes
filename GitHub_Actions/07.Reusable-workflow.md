
---

# Reusable Workflows in GitHub Actions

## 1. What are Reusable Workflows?

* Reusable workflows are GitHub Actions workflows that can be **called from other workflows**.
* They allow you to avoid duplication, enforce consistency, and centralize CI/CD logic.
* Think of them as **functions** that can be invoked with inputs, outputs, and secrets.

---

## 2. Benefits

* **DRY (Don’t Repeat Yourself):** Write common steps once, reuse across repositories or workflows.
* **Consistency:** Standardize testing, deployment, and security workflows.
* **Maintainability:** Update logic in one place, automatically affects all consumers.
* **Security:** Share secrets and permissions safely using input parameters.

---

## 3. Where to Place Reusable Workflows

* Typically stored in the `.github/workflows/` directory of a repo.
* Can be reused:

  * Within the **same repository**.
  * Across **different repositories** in the same organization.

---

## 4. Defining a Reusable Workflow

A workflow is marked reusable using `workflow_call`:

```yaml
# .github/workflows/reusable-deploy.yml
name: Reusable Deployment Workflow

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy to ${{ inputs.environment }}
        run: |
          echo "Deploying to ${{ inputs.environment }}"
```

---

## 5. Calling a Reusable Workflow

You call it using `uses`:

```yaml
# .github/workflows/main.yml
name: Main CI/CD Pipeline

on:
  push:
    branches: [ main ]

jobs:
  call-deploy:
    uses: org-name/repo-name/.github/workflows/reusable-deploy.yml@main
    with:
      environment: "production"
    secrets:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
```

---

## 6. Key Features

* **Inputs:** Pass parameters like environment, region, or versions.
* **Secrets:** Pass securely from the caller workflow.
* **Outputs:** Reusable workflows can return values back to the caller.

Example output in reusable workflow:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      artifact-name: ${{ steps.upload.outputs.artifact }}
    steps:
      - id: upload
        run: echo "artifact=myapp.zip" >> $GITHUB_OUTPUT
```

Caller workflow can use:

```yaml
${{ jobs.call-build.outputs.artifact-name }}
```

---

## 7. Use Cases

* Standardized **CI pipelines** (build, test, lint).
* **Deployment workflows** for different environments.
* **Security scans** (SAST, DAST, dependency scanning).
* **Compliance checks** across multiple repos.
* **Version tagging and release creation**.

---

## 8. Best Practices

* Keep reusable workflows **generic** and parameterized.
* Use **organization-wide repo** (like `org-infra/.github`) for shared workflows.
* Version control them using tags (`@v1`) instead of `@main`.
* Document inputs, outputs, and secrets properly.
* Avoid hardcoding secrets—always pass via caller workflow.

---
