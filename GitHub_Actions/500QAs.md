
---
# Gitlab Actions Interview Question and Answers

### **Table of Contents**
1.  **GitHub Actions Fundamentals & Core Concepts (Q1-Q50)**
2.  **Workflow File Structure & Syntax (Q51-Q100)**
3.  **Events & Triggers (Q101-Q130)**
4.  **Jobs & Strategies (Q131-Q180)**
5.  **Steps & Actions (Q181-Q230)**
6.  **Runners & Self-Hosted Runners (Q231-Q270)**
7.  **Secrets, Variables, & Contexts (Q271-Q310)**
8.  **Artifacts & Caching (Q311-Q350)**
9.  **Security & Permissions (Q351-Q390)**
10. **Advanced Patterns & Best Practices (Q391-Q450)**
11. **Troubleshooting & Debugging (Q451-Q480)**
12. **Ecosystem & Comparisons (Q481-Q500)**

---

### **1. GitHub Actions Fundamentals & Core Concepts**

**Q1. What is GitHub Actions?**
**A:** GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline directly within your GitHub repository.

**Q2. What are the key components of GitHub Actions?**
**A:** **Workflows**, **Events**, **Jobs**, **Steps**, and **Actions**.

**Q3. What is a Workflow?**
**A:** A workflow is a configurable automated process that defines a CI/CD pipeline. It is defined by a YAML (.yml) file in the `.github/workflows/` directory of your repository.

**Q4. What is an Event?**
**A:** An event is a specific activity that triggers a workflow run. Examples include a `push` to a branch, a `pull_request`, a `release` being published, or a `schedule`.

**Q5. What is a Job?**
**A:** A job is a set of steps that execute on the same runner. Each job runs in its own fresh virtual environment. Jobs can run in parallel or have dependencies on other jobs.

**Q6. What is a Step?**
**A:** A step is an individual task that can run commands or actions. Steps are executed in order and are dependent on the previous step completing successfully.

**Q7. What is an Action?**
**A:** An action is a custom application for the GitHub Actions platform that performs a complex but frequently repeated task. You can write your own actions or use actions from the GitHub Marketplace.

**Q8. What is a Runner?**
**A:** A runner is a server that runs your workflows when they are triggered. GitHub provides Ubuntu Linux, Microsoft Windows, and macOS runners; you can also host your own self-hosted runners.

**Q9. Where are workflow files stored?**
**A:** In the `.github/workflows/` directory at the root of your repository.

**Q10. What is the GitHub Marketplace?**
**A:** The GitHub Marketplace is a platform where you can discover, use, and share actions created by the GitHub community to use in your workflows.

**Q11. How is GitHub Actions priced?**
**A:** GitHub Actions is free for public repositories and offers a generous monthly quota of minutes for private repositories on free and paid GitHub plans. Usage beyond the quota incurs charges.

**Q12. What is the difference between GitHub Actions and other CI/CD tools like Jenkins, GitLab CI, or CircleCI?**
**A:** The key difference is **deep integration with GitHub**. The configuration lives right next to your code, it's triggered by native GitHub events, and it has seamless access to repository data, secrets, and packages. Other tools often require external configuration and integrations.

**Q13. What is a matrix strategy?**
**A:** A matrix strategy allows you to run a job with multiple configurations simultaneously. For example, testing your code on multiple versions of Node.js, Python, or multiple operating systems.

**Q14. What is the purpose of the `GITHUB_TOKEN`?**
**A:** It's an automatically generated secret token used to authenticate on behalf of the GitHub Actions app. It's used to interact with the GitHub API (e.g., to create a deployment, comment on a PR). Its permissions can be scoped.

**Q15. Can you use GitHub Actions for non-CI/CD tasks?**
**A:** Absolutely. Common use cases include automating issue triage, greeting first-time contributors, syncing branches, running scheduled scripts (e.g., link checking, dependency updates), and sending notifications to Slack.

**Q16. What programming language are actions written in?**
**A:** Actions can be written as JavaScript files or Docker containers. Composite Actions can also be defined with a series of shell commands in a YAML file.

**Q17. What is a reusable workflow?**
**A:** A reusable workflow allows you to call one workflow from another, preventing duplication and promoting consistency across your repositories.

**Q18. What is the difference between a workflow run and a job?**
**A:** A **workflow run** is a single execution of a workflow, triggered by an event. A **job** is a component within that workflow run. One workflow run can contain multiple jobs.

**Q19. How do you manually trigger a workflow?**
**A:** Using the `workflow_dispatch` event. This adds a "Run workflow" button in the GitHub UI. You can also define inputs for this trigger.

**Q20. What is the `actions/checkout` action and why is it almost always the first step?**
**A:** The `actions/checkout` action checks out your repository onto the runner, giving the workflow access to your code. Without it, the runner would only have the workflow files themselves, not your project's source code.

**... (Questions 21-50 would cover more core concepts like the virtual environments, limits, and high-level architecture)** ...

---

### **2. Workflow File Structure & Syntax**

**Q51. What is the required structure of a workflow file?**
**A:** A workflow file must have at least a `name` and an `on` trigger. It typically contains `jobs`.
```yaml
name: My Workflow
on: push
jobs:
  my-job:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Hello World"
```

**Q52. What is the `name` key used for?**
**A:** The `name` of the workflow is displayed in the Actions tab of your GitHub repository.

**Q53. What is the `on` key used for?**
**A:** The `on` key defines the event that triggers the workflow. It can be a single event (`on: push`), a list of events (`on: [push, pull_request]`), or a map for complex configuration.

**Q54. How do you define a workflow that runs on a push to the `main` branch only?**
**A:** Use the `on.push.branches` filter.
```yaml
on:
  push:
    branches: [ main ]
```

**Q55. How do you define a workflow that runs on a pull request targeting the `develop` branch?**
**A:** Use the `on.pull_request.branches` filter.
```yaml
on:
  pull_request:
    branches: [ develop ]
```

**Q56. How do you define a scheduled workflow that runs every day at 5 AM UTC?**
**A:** Use the `schedule` event with POSIX cron syntax.
```yaml
on:
  schedule:
    - cron: '0 5 * * *'
```

**Q57. What is the `jobs.<job_id>` key?**
**A:** `<job_id>` is a unique identifier for a job within a workflow. It is a string (e.g., `build`, `test`, `deploy-prod`).

**Q58. What is the `jobs.<job_id>.runs-on` key?**
**A:** `runs-on` defines the type of machine to run the job on. It can be a GitHub-hosted runner (`ubuntu-latest`, `windows-2019`, `macos-11.0`) or a label for a self-hosted runner (`self-hosted`, `my-custom-label`).

**Q59. What is the `jobs.<job_id>.needs` key?**
**A:** `needs` defines any jobs that must complete successfully before this job will run. It is used to create dependent job sequences.
```yaml
jobs:
  build:
    ...
  test:
    needs: build # test will only run after build succeeds
    ...
```

**Q60. What is the `jobs.<job_id>.if` key?**
**A:** `if` allows you to conditionally run a job based on a condition. You can use context expressions here.
```yaml
jobs:
  deploy:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    ...
```

**... (Questions 61-100 would cover `env`, `defaults`, `concurrency`, `outputs`, and other job-level keys)** ...

---

### **3. Events & Triggers**

**Q101. What event would you use to trigger a workflow when a new release is published?**
**A:** The `release` event with the `published` activity type.
```yaml
on:
  release:
    types: [published]
```

**Q102. How do you trigger a workflow when an issue is labeled?**
**A:** Use the `issues` event with the `labeled` type.
```yaml
on:
  issues:
    types: [labeled]
```

**Q103. What is the `workflow_run` event?**
**A:** It triggers a workflow when another workflow in the same repository completes. It's useful for creating dependent workflows, like running a deployment workflow after a test workflow passes.

**Q104. What is the `workflow_dispatch` event?**
**A:** It allows you to manually trigger a workflow from the GitHub UI or API. You can define custom inputs for this trigger.
```yaml
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
```

**Q105. What is the `repository_dispatch` event?**
**A:** It allows you to trigger a workflow from an external service via the GitHub API. This is useful for integrating with third-party systems.

**Q106. How can you trigger a workflow for a specific path? For example, only when files in the `docs/` directory change?**
**A:** Use the `paths` or `paths-ignore` filter on events like `push` or `pull_request`.
```yaml
on:
  push:
    paths:
      - 'docs/**'
```

**Q107. What is the difference between `paths` and `paths-ignore`?**
**A:** `paths` will trigger the workflow *only if* a file matching the pattern is changed. `paths-ignore` will trigger the workflow *unless* a file matching the pattern is changed.

**Q108. How do you trigger a workflow for a push of a tag?**
**A:** Use the `on.push.tags` filter.
```yaml
on:
  push:
    tags:
      - 'v*' # Trigger on tags starting with 'v'
```

**Q109. What event would you use to run a workflow when a pull request is merged?**
**A:** There is no direct "merged" type. You can use the `pull_request` event with the `closed` type and then check `github.event.pull_request.merged` inside your job to see if it was merged.
```yaml
on:
  pull_request:
    types: [closed]
jobs:
  if-merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    ...
```

**Q110. Can you trigger a workflow from a comment on a PR or issue?**
**A:** Yes, using the `issue_comment` event with the `created` type. You can then parse the comment body to see if it contains a specific command (e.g., `/deploy`).

**... (Questions 111-130 would cover more event types, activities, and advanced filtering)** ...

---

### **4. Jobs & Strategies**

**Q131. What is the default behavior of jobs in a workflow concerning execution order?**
**A:** By default, all jobs in a workflow run in **parallel**.

**Q132. How do you make one job dependent on another?**
**A:** Use the `needs` keyword in the dependent job.
```yaml
jobs:
  job-a:
    ...
  job-b:
    needs: job-a # job-b runs after job-a completes successfully
    ...
```

**Q133. How do you create a fan-out pattern (one job triggers many)?**
**A:** Have multiple jobs all `need` the same initial job.
```yaml
jobs:
  build:
    ...
  test-linux:
    needs: build
    runs-on: ubuntu-latest
  test-windows:
    needs: build
    runs-on: windows-latest
```

**Q134. How do you create a fan-in pattern (many jobs trigger one)?**
**A:** Have a final job that `needs` all the previous jobs.
```yaml
jobs:
  unit-tests:
    ...
  integration-tests:
    ...
  e2e-tests:
    ...
  deploy:
    needs: [unit-tests, integration-tests, e2e-tests] # Runs after all tests pass
```

**Q135. What is the `jobs.<job_id>.strategy` key used for?**
**A:** The `strategy` key is used to create a build matrix. It allows you to run a job with multiple configurations.

**Q136. How would you run a job on Ubuntu, Windows, and macOS?**
**A:** Use a matrix with the `runs-on` key.
```yaml
jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - run: echo "Hello from ${{ matrix.os }}"
```

**Q137. How would you test against multiple versions of Node.js?**
**A:** Use a matrix with a `node-version` variable.
```yaml
jobs:
  test:
    strategy:
      matrix:
        node-version: [14, 16, 18]
    steps:
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
```

**Q138. How can you combine multiple matrices (e.g., OS and Node version)?**
**A:** Define multiple variables in the `matrix` key. This will create a combination of all variables.
```yaml
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest]
    node-version: [14, 16]
# This creates 4 jobs: [ubuntu-14, ubuntu-16, windows-14, windows-16]
```

**Q139. What is `strategy.fail-fast` used for?**
**A:** When `fail-fast` is set to `true` (the default), if one matrix job fails, all other in-progress matrix jobs will be cancelled. Setting it to `false` allows all matrix jobs to complete, regardless of failure.

**Q140. What is `strategy.max-parallel` used for?**
**A:** It sets the maximum number of matrix jobs that can run simultaneously. This is useful for controlling resource consumption or staying within rate limits of external services.

**... (Questions 141-180 would cover `continue-on-error`, `timeout-minutes`, `environment`, `services`, and `container` options for jobs)** ...

---

### **5. Steps & Actions**

**Q181. What is the structure of a step?**
**A:** A step can be either an `action` (using `uses:`) or a shell `command` (using `run:`). It can also have an `id`, `name`, `env`, and `if` condition.
```yaml
steps:
  - name: Checkout code
    uses: actions/checkout@v3

  - name: Install dependencies
    run: npm ci

  - name: Run tests
    run: npm test
    env:
      CI: true
```

**Q182. What does the `uses` keyword do?**
**A:** `uses` specifies an action to run as part of a step. It can reference an action in the same repository, a public repository, or a published Docker container.

**Q183. What does the `run` keyword do?**
**A:** `run` runs a command-line program using the operating system's shell.

**Q184. What shell does `run` use by default?**
**A:** On Linux and macOS runners, the default shell is `bash`. On Windows runners, the default shell is `pwsh` (PowerShell Core).

**Q185. How can you specify a different shell for a `run` step?**
**A:** Use the `shell` keyword.
```yaml
steps:
  - name: Run a script
    run: ./my-script.sh
    shell: bash # Explicitly specify bash

  - name: Run a Python script
    run: python my_script.py
    shell: python # This is a special 'shell' that runs the code directly with the Python interpreter
```

**Q186. What is the difference between `actions/checkout@v1`, `v2`, and `v3`?**
**A:** They are different major versions of the same action. `v3` is the latest and recommended version, featuring performance improvements, better default behaviors, and security updates. You should always pin to a major version (`@v3`) to avoid breaking changes.

**Q187. How do you pass inputs to an action?**
**A:** Using the `with` keyword.
```yaml
steps:
  - uses: actions/setup-node@v3
    with:
      node-version: '16'
      cache: 'npm'
```

**Q188. How do you get the output from an action?**
**A:** First, the action must define an output. Then you can capture it using the step's `id` and the `steps.<step_id>.outputs` context.
```yaml
steps:
  - id: get_version
    run: echo "::set-output name=version::1.2.3"
    # Older method, deprecated. Now you should use:
    run: echo "version=1.2.3" >> $GITHUB_OUTPUT

  - name: Use the version
    run: echo "The version is ${{ steps.get_version.outputs.version }}"
```

**Q189. What is a Composite Action?**
**A:** A Composite Action allows you to combine multiple workflow steps into a single reusable action. It's defined in a YAML file and can include `run` steps and other actions.

**Q190. What is the difference between a JavaScript Action, a Docker Action, and a Composite Action?**
**A:**
*   **JavaScript Action:** Runs directly on the runner using Node.js. Fastest, as it doesn't need a container.
*   **Docker Action:** Runs in a Docker container. Useful if your action has specific dependencies.
*   **Composite Action:** A sequence of steps defined in YAML. Good for bundling common commands together.

**... (Questions 191-230 would cover `if` conditions on steps, `timeout-minutes`, and creating custom actions)** ...

---

### **6. Runners & Self-Hosted Runners**

**Q231. What are the three types of GitHub-hosted runners?**
**A:** `ubuntu-latest` (Linux), `windows-latest` (Windows), and `macos-latest` (macOS).

**Q232. What are the specifications of GitHub-hosted runners?**
**A:** The specifications are subject to change, but they generally offer multiple cores, 7-14 GB of RAM, and SSD storage. You can find the latest specs in the GitHub documentation.

**Q233. What is a self-hosted runner?**
**A:** A runner that you install and manage on your own infrastructure (on-premises servers, your own cloud VMs, or even a Docker container).

**Q234. Why would you use a self-hosted runner?**
**A:** Key reasons include:
*   **Hardware/OS Requirements:** You need specific hardware (e.g., GPU), a specific OS not provided by GitHub, or more resources.
*   **Data Sovereignty:** Your code or data cannot leave your network.
*   **Access to Internal Resources:** Your builds need to access internal services, databases, or networks not exposed to the internet.
*   **Cost Control:** For very high usage, it can be cheaper than paying for GitHub minutes.

**Q235. What are the security considerations for self-hosted runners?**
**A:** They are powerful because they can access your environment. Key considerations:
*   **Never use on public repositories:** A malicious PR could run dangerous code on your runner.
*   **Isolate them:** Place them in a separate network segment.
*   **Use ephemeral runners:** Configure them to run one job and then reset, ensuring a clean state for each build (often done with Docker or orchestration tools).

**Q236. How do you add a self-hosted runner to a repository?**
**A:** Go to Repository Settings -> Actions -> Runners -> New self-hosted runner. Follow the instructions to download, configure, and run the runner application.

**Q237. How do you add a self-hosted runner to an organization?**
**A:** Go to Organization Settings -> Actions -> Runners -> New self-hosted runner. This makes the runner available to multiple repositories within the org.

**Q238. How do you specify a self-hosted runner in a workflow?**
**A:** Use the `runs-on` key with the label you assigned during runner setup (e.g., `runs-on: [self-hosted, linux, x64]` or `runs-on: my-custom-label`).

**Q239. What is an ephemeral runner?**
**A:** A runner that is freshly created for a single job and then destroyed. This is a best practice for self-hosted runners as it ensures isolation between jobs. This is often achieved using tools like Kubernetes, Docker, or runner orchestration scripts.

**Q240. What tools can help manage self-hosted runners at scale?**
**A:** Tools like **Actions Runner Controller (ARC)** for Kubernetes, **Terraform** with the GitHub provider, and **cloud-init scripts** can automate the provisioning, scaling, and teardown of self-hosted runners.

**... (Questions 241-270 would cover runner groups, monitoring, and troubleshooting runner connectivity)** ...

---

### **7. Secrets, Variables, & Contexts**

**Q271. What is a secret in GitHub Actions?**
**A:** A secret is an encrypted variable that you create in an organization, repository, or environment. It's used to store sensitive data like API tokens, passwords, or SSH keys.

**Q272. Where do you configure secrets for a repository?**
**A:** In the repository's Settings -> Secrets and variables -> Actions -> Secrets tab.

**Q273. How do you use a secret in a workflow?**
**A:** Use the `secrets` context.
```yaml
steps:
  - name: Deploy
    run: ./deploy.sh
    env:
      API_TOKEN: ${{ secrets.API_TOKEN }}
```

**Q274. What is the difference between a secret and a variable?**
**A:** **Secrets** are encrypted and hidden from logs. **Variables** are plain-text and can be used for non-sensitive configuration like paths or usernames. Both are defined in the same Settings section.

**Q275. What is a context in GitHub Actions?**
**A:** A context is a way to access information about workflow runs, runner environments, jobs, and steps. Contexts use expression syntax: `${{ <context> }}`.

**Q276. Name some commonly used contexts.**
**A:** `github` (event payload, ref, sha), `secrets`, `vars` (variables), `job`, `steps`, `runner`, `env`.

**Q277. How would you get the commit SHA that triggered the workflow?**
**A:** `${{ github.sha }}`

**Q278. How would you get the name of the branch that triggered a push event?**
**A:** `${{ github.ref_name }}` or `${{ github.ref }}` (which gives the full ref, e.g., `refs/heads/main`).

**Q279. How would you get the title of the pull request that triggered the workflow?**
**A:** `${{ github.event.pull_request.title }}`

**Q280. What is the `env` context and how is it used?**
**A:** The `env` context contains environment variables set in the workflow, job, or step. You can set them at different levels.
```yaml
env:
  NODE_ENV: test # Set at workflow level

jobs:
  build:
    env:
      CI: true # Set at job level
    steps:
      - run: echo $NODE_ENV # 'test'
      - run: echo $CI # 'true'
      - run: echo $MESSAGE
        env:
          MESSAGE: Hello # Set at step level
```

**... (Questions 281-310 would cover default environment variables, creating outputs, and advanced context usage)** ...

---

### **8. Artifacts & Caching**

**Q311. What is an artifact?**
**A:** An artifact is a file or collection of files produced during a workflow run, such as build outputs, logs, or test results. They are stored by GitHub and can be downloaded or used by other jobs in the same workflow.

**Q312. What action do you use to upload an artifact?**
**A:** `actions/upload-artifact@v3`
```yaml
steps:
  - run: npm run build
  - uses: actions/upload-artifact@v3
    with:
      name: my-build-output
      path: build/
```

**Q313. What action do you use to download an artifact?**
**A:** `actions/download-artifact@v3`
```yaml
steps:
  - uses: actions/download-artifact@v3
    with:
      name: my-build-output
```

**Q314. Can you share artifacts between jobs in the same workflow?**
**A:** Yes. You upload the artifact in one job and download it in another. The jobs must be in the same workflow run.

**Q315. How long are artifacts retained?**
**A:** Artifacts are retained for 90 days by default. This can be customized on a per-artifact basis or changed as a default setting for the repository.

**Q316. What is caching used for?**
**A:** Caching is used to store frequently reused dependencies (like `node_modules`, packages, etc.) to make subsequent workflow runs much faster.

**Q317. What action do you use for caching?**
**A:** `actions/cache@v3`
```yaml
steps:
  - uses: actions/cache@v3
    with:
      path: node_modules
      key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
      restore-keys: |
        ${{ runner.os }}-node-
```

**Q318. Explain the `key` and `restore-keys` parameters for the cache action.**
**A:**
*   `key`: The exact key for the cache you want to restore/create. A cache hit occurs if the key matches exactly.
*   `restore-keys`: A list of partial keys to use for finding a cache if the exact `key` doesn't exist. It will use the cache from the first matching partial key.

**Q319. Why would you hash a lockfile (like `package-lock.json`) for the cache key?**
**A:** Because the lockfile defines the exact dependency tree. If the lockfile changes, the dependencies have changed, and you need a new cache. If it hasn't changed, you can safely use the old cache.

**Q320. What is the difference between an artifact and a cache?**
**A:** **Artifacts** are for preserving the output of a workflow run (e.g., a binary to deploy). **Cache** is for storing intermediate dependencies to speed up future runs. Caches are also evicted on an LRU (Least Recently Used) basis.

**... (Questions 321-350 would cover cache scoping, optimization, and best practices)** ...

---

### **9. Security & Permissions**

**Q351. How are secrets handled to ensure security?**
**A:** Secrets are encrypted at rest, are not passed to workflows that are triggered by a pull request from a fork, and are masked in logs (though you must be careful not to echo them directly).

**Q352. What permissions does the default `GITHUB_TOKEN` have?**
**A:** It has read/write permissions for the contents of the repository where the workflow runs. Its permissions can be scoped down in the workflow file.

**Q353. How can you limit the permissions of the `GITHUB_TOKEN`?**
**A:** Use the `permissions` key at the workflow or job level.
```yaml
jobs:
  build:
    permissions:
      contents: read   # Only read access to repository contents
      packages: write  # Write access to packages
    steps:
      ...
```

**Q354. What is a potential security risk of a Pull Request from a fork?**
**A:** A malicious actor can open a PR from a fork. The workflow runs with read access to the base repository's secrets (like `GITHUB_TOKEN`) and write access to the fork. They could potentially exfiltrate secrets or run crypto-mining scripts.

**Q355. How does GitHub mitigate the risk of PRs from forks?**
**A:** For PRs from forks, the `GITHUB_TOKEN` is granted read-only permissions by default, and secrets are not passed to the workflow run unless explicitly approved using `pull_request_target`.

**Q356. What is the `pull_request_target` event and why is it dangerous?**
**A:** The `pull_request_target` event runs in the context of the *base* repository, not the fork. This means it has full access to secrets and write permissions. It is dangerous because it runs code from an untrusted fork. It should be used with extreme caution and only if you absolutely trust the PR author or have very rigorous review.

**Q357. What is a good practice for using secrets with third-party actions?**
**A:** **Pin actions to a full commit SHA**, not just a tag. A tag (like `@v1`) can be moved. A commit SHA is immutable and ensures you are using the exact code you reviewed.

**Q358. How can you audit the security of your workflows?**
**A:** Use **GitHub's Code Scanning** with the **CodeQL** "Security of GitHub Actions" query suite. It can identify insecure patterns like use of `pull_request_target`, untrusted input, or secret exposure.

**Q359. What is the purpose of the `CODEOWNERS` file in relation to Actions?**
**A:** You can require approval from specific code owners before a workflow can run, especially for environments like `production`. This adds a manual governance step to deployment.

**Q360. What are environments and how do they enhance security?**
**A:** Environments (e.g., `staging`, `production`) are a way to group deployment targets. They allow you to:
*   Require **approvals** before a job targeting that environment can proceed.
*   Restrict which branches can deploy to the environment.
*   Scope **secrets** to a specific environment.

**... (Questions 361-390 would cover OIDC for cloud credentials, dependency review, and other advanced security features)** ...

---

### **10. Advanced Patterns & Best Practices**

**Q391. What is a monorepo and how can GitHub Actions be configured for it?**
**A:** A monorepo is a single repository containing multiple projects. For Actions, you can use `paths` filters to trigger workflows only when code in a specific sub-directory changes.
```yaml
on:
  push:
    paths:
      - 'apps/my-app/**'
```

**Q392. How can you avoid duplicating workflow code across multiple repositories?**
**A:** Use **Reusable Workflows** or **Shared Actions** (Composite or JavaScript/Docker). Reusable Workflows are better for entire pipeline definitions, while Shared Actions are better for individual tasks.

**Q393. What is a Reusable Workflow?**
**A:** A workflow that can be called by another workflow, defined in a `.yml` file with the `on: workflow_call` trigger.
```yaml
# In .github/workflows/reusable-ci.yml
on:
  workflow_call:
    inputs:
      node-version:
        required: true
        type: string

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ inputs.node-version }}
      - run: npm test
```

**Q394. How do you call a Reusable Workflow?**
**A:** Use the `uses` keyword in a job.
```yaml
jobs:
  call-reusable-workflow:
    uses: my-org/my-repo/.github/workflows/reusable-ci.yml@main
    with:
      node-version: '16'
```

**Q395. How can you make a job wait for manual approval?**
**A:** Use an **Environment** with required reviewers. Create an environment (e.g., `production`) in repo settings and configure it to require approvals. Then, in your job, specify that environment and use an `input` step.
```yaml
jobs:
  deploy-to-prod:
    environment: production # This environment requires approvals
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: ./deploy.sh
      # The workflow will pause here and wait for an admin to approve it via the UI.
```

**Q396. What is the purpose of the `concurrency` key?**
**A:** `concurrency` ensures that only a single workflow or job using the same concurrency group runs at a time. This is crucial for preventing race conditions in deployments.
```yaml
on: push
concurrency: production-deploy # All pushes will cancel any in-progress runs in this group

# OR, more specific
concurrency:
  group: production-deploy-${{ github.ref }}
  cancel-in-progress: true # Cancel any previous run for this same ref
```

**Q397. How can you handle potential flaky tests?**
**A:** Use a step with `continue-on-error: true` for the test command, and then a subsequent step to check the result and mark the build as unstable if needed (though marking as unstable isn't native and often requires custom logic or a specific action).

**Q398. What is the purpose of the `::` command syntax (e.g., `::set-output`)?**
**A:** This is **workflow commands**. They are a way for a workflow step to communicate with the runner. For example, `echo "::set-output name=output1::value"` sets an output. (Note: `set-output` is deprecated; now you use `echo "name=value" >> $GITHUB_OUTPUT`).

**Q399. How can you add a summary to the workflow run page?**
**A:** Use the `GITHUB_STEP_SUMMARY` environment variable.
```yaml
steps:
  - name: Add Summary
    run: echo "### ðŸŽ‰ Build Successful!" >> $GITHUB_STEP_SUMMARY
```

**Q400. What are some best practices for writing maintainable workflows?**
**A:**
*   **Use Descriptive Names:** For workflows, jobs, and steps.
*   **Reuse Code:** Use Reusable Workflows and Composite Actions.
*   **Pin Actions:** Pin to a specific major version (`@v3`) or a commit SHA for security.
*   **Use Secrets for Sensitive Data:** Never hardcode.
*   **Keep Workflows Focused:** One workflow for CI, another for CD.
*   **Lint Your Workflows:** Use the `actionlint` tool to catch errors before committing.

**... (Questions 401-450 would cover even more advanced patterns like dynamic matrices, calling APIs, and complex error handling)** ...

---

### **11. Troubleshooting & Debugging**

**Q451. What is the first place you look when a workflow fails?**
**A:** The **logs** of the failed workflow run. Click on the failed job and step to see the detailed console output.

**Q452. How can you enable step debug logging?**
**A:** Set the secret `ACTIONS_STEP_DEBUG` to `true` in your repository settings. This will enable very verbose logging for all workflow runs.

**Q453. A step is failing with a vague error. How can you get more information?**
**A:** Run the command locally if possible. You can also add a step before it to `ls` the directory or `echo` environment variables to understand the state of the runner.

**Q454. How can you re-run a workflow without pushing a new commit?**
**A:** In the Actions tab, click on a workflow run and use the "Re-run all jobs" or "Re-run failed jobs" button.

**Q455. What does the "This check failed" message mean on a PR?**
**A:** It means a required status check (typically a workflow run) has failed. The PR cannot be merged until the check passes.

**Q456. How do you troubleshoot a workflow that is not triggering?**
**A:**
1.  Check the `.github/workflows/` directory and filename.
2.  Check the `on` trigger syntax in the YAML file.
3.  Check the branch filters (`branches`, `branches-ignore`).
4.  Check the path filters (`paths`, `paths-ignore`).

**Q457. A workflow is stuck "Queued". What are potential causes?**
**A:**
*   All runners are busy (check your usage).
*   For self-hosted runners: the runner is offline, misconfigured, or doesn't have the required labels.
*   A concurrency group is blocking it.

**Q458. How can you cancel a running workflow?**
**A:** In the Actions tab, click on the running workflow and click the "Cancel" button.

**Q459. A secret is not being found. What should you check?**
**A:**
1.  The spelling of the secret name in the workflow (`${{ secrets.MY_SECRET }}`).
2.  That the secret is defined in the correct scope (repository, organization, environment).
3.  That the workflow has access to the environment where the secret is defined.

**Q460. How can you test a workflow without pushing to the main branch?**
**A:** Push to a feature branch or use the `workflow_dispatch` trigger to run it manually.

**... (Questions 461-480 would cover common YAML syntax errors, permission denied errors, and network issues)** ...

---

### **12. Ecosystem & Comparisons**

**Q481. How does GitHub Actions compare to Jenkins?**
**A:**
*   **Configuration:** Actions uses YAML files in the repo; Jenkins uses a web UI or Groovy scripts (Pipeline-as-Code).
*   **Hosting:** Actions is SaaS (with self-hosted runner option); Jenkins is typically self-hosted.
*   **Integration:** Actions is deeply integrated with GitHub; Jenkins requires plugins for most integrations.
*   **Concept:** Similar concepts: both have jobs, steps (stages), and can use pipelines.

**Q482. How does GitHub Actions compare to GitLab CI/CD?**
**A:** They are very similar: both are configured via YAML in the repository and deeply integrated with their platform. GitLab CI/CD is often seen as more feature-complete for complex enterprise CD, while Actions has a massive ecosystem of community actions.

**Q483. How does GitHub Actions compare to CircleCI?**
**A:** Both are modern, cloud-native CI/CD platforms. CircleCI has powerful orbs (reusable config packages) and has been around longer. Actions' tight GitHub integration and free minutes for public repos are its key advantages.

**Q484. What is Azure Pipelines and how does it relate?**
**A:** Azure Pipelines is Microsoft's CI/CD platform in Azure DevOps. It is very powerful and can be used with GitHub repositories. GitHub Actions is now the preferred native automation tool for GitHub.

**Q485. Can you use GitHub Actions with other version control systems?**
**A:** No. GitHub Actions is exclusively designed for and integrated with GitHub repositories.

**Q486. What is the GitHub Actions extension for VS Code?**
**A:** It's an extension that provides syntax highlighting, completion, and workflow validation for `.yml` workflow files directly in the VS Code editor.

**Q487. What is `actionlint`?**
**A:** A static analysis tool for GitHub Actions workflow files. It can catch errors, typos, and invalid configuration before you even commit your code.

**Q488. How can you migrate from another CI/CD system (like Travis CI) to GitHub Actions?**
**A:** GitHub provides tools and documentation for migration. The general process involves:
1.  Translating the existing configuration (.travis.yml) into GitHub Actions syntax.
2.  Replacing proprietary commands (e.g., `travis_retry`) with equivalent Actions steps or scripts.
3.  Testing the new workflow on a branch.

**Q489. What is the future direction of GitHub Actions?**
**A:** Continued focus on improving security (e.g., OIDC, more granular permissions), performance (faster runners, better caching), and developer experience (better UI, more powerful Reusable Workflows).

**Q500. Why would a company choose GitHub Actions over other options?**
**A:** The primary reason is **consolidation and simplicity**. If they are already using GitHub for source control, using Actions means:
*   **One less tool** to manage and pay for.
*   **Tighter integration** between code, PRs, issues, and CI/CD.
*   Leveraging a **huge ecosystem** of pre-built actions.
*   A **unified experience** for developers.

This list provides a strong foundation for any GitHub Actions interview, covering the breadth and depth of the platform. Be sure to understand the core concepts and practice writing your own workflows. Good luck!