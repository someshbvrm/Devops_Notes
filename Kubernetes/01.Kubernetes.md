
---

# 🐳 Docker Swarm vs ☸️ Kubernetes

---

## 🔹 **Docker Swarm**

**Definition**: A lightweight container orchestration tool built into Docker.
**Best Use**: Suitable for **small to medium** microservices deployments.

### ❌ Limitations of Docker Swarm

* 🚫 **No Auto Scaling** → Cannot automatically add/remove containers based on demand.
* 🚫 **No Self-Healing** → If a container fails, it won’t restart automatically.
* 🚫 **Not for Enterprise** → Limited for large-scale deployments.

---

## 🔹 **Kubernetes (K8s)**

**Definition**: A powerful, open-source container orchestration platform (think of it as the **pilot of containers**).
**Best Use**: Designed for **large-scale, production-grade** deployments.

### ✅ Key Functions

* ⚡ **Automatic Provisioning** – Creates and manages containers automatically.
* 📈 **Scaling (Up/Down)** – Adjusts the number of containers based on workload.
* ⚖️ **Load Balancing** – Distributes traffic across containers efficiently.
* 🔄 **Self-Healing** – Restarts failed containers automatically.
* 🗑️ **Destroy** – Removes unnecessary or failed containers.
* ⏮️ **Update & Rollback** – Deploy updates and roll back if issues occur.

---

# ☸️ Kubernetes Architecture

Kubernetes consists of **two main parts**:

### 🧠 Control Plane (Master) – The Brains

* 📡 **API Server** → Entry point; receives commands (`kubectl`)
* 🎯 **Scheduler** → Decides which node runs a new pod
* 🛠️ **Controller Manager** → Ensures desired cluster state
* 🗄️ **etcd** → Distributed key-value store for cluster data

### ⚙️ Nodes (Workers)

* 👷 **Kubelet** → Ensures pods are running on nodes
* 🔀 **Kube-Proxy** → Handles networking & load balancing
* 🐳 **Container Runtime** → Runs containers (Docker, containerd, CRI-O)
* 📦 **Pods** → Smallest deployable unit (1 or more containers)

---

# 🖥️ Kubernetes Command-Line Tools

* 🔧 **kubectl** → Main CLI for cluster interaction

  ```bash
  kubectl get pods
  kubectl apply -f deployment.yaml
  ```

* ☁️ **eksctl** → AWS-specific Kubernetes management tool

* 🚀 **kubeadm** → Bootstrap/init Kubernetes cluster

  ```bash
  kubeadm init
  kubeadm join
  ```

* 🖼️ **Kubernetes Dashboard** → Web GUI

* 🌐 **kube-dns** → DNS inside cluster

* 🗂️ **Namespaces** → Virtual clusters

---

# 📦 Pods in Kubernetes

Pods = **Encapsulation of containers, storage, and network resources**.
👉 They are the **smallest deployable unit** in Kubernetes.

### 📌 Two Types of Pods:

1️⃣ **Single-container Pod** (most common)
2️⃣ **Multi-container Pod** (sidecar pattern, tightly coupled apps)

---

## 📝 Example – Single Container Pod

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers:
  - name: nginx-container
    image: nginx:latest
    ports:
    - containerPort: 80
```

---

## 📝 Example – Multi-Container Pod

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: multi-container-pod
spec:
  containers:
  - name: main-container
    image: nginx:latest
    ports:
    - containerPort: 80
  - name: sidecar-container
    image: busybox:latest
    command: ["sh", "-c", "while true; do echo 'Sidecar Running'; sleep 5; done"]
```

---

# 🕹️ Pod Controllers

### 🔹 Types

* 📤 **Deployment** → Stateless apps
* 🌍 **DaemonSet** → One pod per node
* 🗄️ **StatefulSet** → Stateful apps (databases, Kafka)

---

## ⚖️ Deployment vs DaemonSet vs StatefulSet

| Controller      | Purpose                        | Scaling                   | Pod Identity         | Use Case                        |
| --------------- | ------------------------------ | ------------------------- | -------------------- | ------------------------------- |
| **Deployment**  | Run/manage stateless apps      | Multiple replicas         | Interchangeable pods | Web apps, REST APIs             |
| **DaemonSet**   | One pod per node (agent model) | Adds/removes with nodes   | One copy per node    | Logging, monitoring, CNI agents |
| **StatefulSet** | Run/manage stateful apps       | Unique, sticky identities | Persistent identity  | DBs, Kafka, Zookeeper           |

---

# 📈 Kubernetes Scalability Limits

* 🛑 **Max pods per node** → `110`
* 🛑 **Max nodes per cluster** → `5000`
* 🛑 **Max pods per cluster** → `150,000`
* 🛑 **Max containers per cluster** → `300,000`

---

# 🚀 Kubernetes Deployment

### 📌 Definition

A **Deployment** is used for **stateless apps**. Ensures desired replicas, supports **rolling updates & rollbacks**.

### 🛠️ Deployment Example

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: web
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: web-container
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```

👉 Apply in namespace:

```bash
kubectl apply -f nginx-deployment.yml --namespace=ictm-dev
```

---

### 📌 Deployment Commands

```bash
kubectl create deployment nginx --image=nginx
kubectl get deployments
kubectl describe deployment nginx
kubectl scale deployment nginx --replicas=5
kubectl rollout status deployment nginx
kubectl rollout undo deployment nginx
```

---

# 🌍 Kubernetes Services

| Type             | Scope/Access              | Typical Use Case                         |
| ---------------- | ------------------------- | ---------------------------------------- |
| **ClusterIP**    | Internal only             | Backend services, inter-pod comms        |
| **NodePort**     | External via NodeIP\:Port | Simple external access (dev/test)        |
| **LoadBalancer** | External via Public IP    | Production external services             |
| **ExternalName** | DNS mapping to external   | Use external DB, external APIs           |
| **Headless**     | No ClusterIP, DNS per pod | StatefulSets, direct pod addressing      |
| **Ingress**      | HTTP/HTTPS routing        | Websites, APIs, multiple services access |

---

# 💾 Kubernetes Storage

### 🗄️ Persistent Volume (PV)

* Cluster-wide storage resource
* Created by **Admin** (or dynamically via StorageClass)
* Lifecycle independent of Pods

### 📥 Persistent Volume Claim (PVC)

* Storage **request** from a user/app
* Namespace-level object
* Can trigger dynamic PV provisioning

👉 **In short**:

* **PV** = Actual storage (Admin-defined)
* **PVC** = Request for storage (User-defined)
* **Pod** = Uses PVC to consume PV

---

## 📝 PV & PVC Example

```yaml
# Persistent Volume
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-example
spec:
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data"
```

```yaml
# Persistent Volume Claim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-example
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
```

```yaml
# Pod using PVC
apiVersion: v1
kind: Pod
metadata:
  name: pod-using-pvc
spec:
  containers:
  - name: app
    image: nginx
    volumeMounts:
    - mountPath: "/usr/share/nginx/html"
      name: storage
  volumes:
  - name: storage
    persistentVolumeClaim:
      claimName: pvc-example
```

---

# 🏗️ StatefulSet

* For **stateful apps** (databases, message brokers, monitoring, storage nodes).
* Provides:

  * ✅ Stable, unique network IDs
  * ✅ Persistent storage
  * ✅ Ordered deployment/scaling
  * ✅ Graceful rolling updates

---

📌 **Summary**

* 🐳 Docker Swarm → lightweight, good for small setups.
* ☸️ Kubernetes → enterprise-grade orchestration with auto-scaling, self-healing, load balancing.
* 📦 Pods → smallest deployable unit.
* 🕹️ Controllers → Deployments (stateless), DaemonSets (per node), StatefulSets (stateful apps).
* 🌍 Services → Expose apps internally or externally.
* 💾 PV/PVC → Manage persistent storage.

---
