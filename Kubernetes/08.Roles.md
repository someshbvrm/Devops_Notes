
---

# 🔐 Kubernetes RBAC (Role-Based Access Control)

📌 **RBAC** regulates access to resources based on **roles** assigned to users/groups.

* Permissions are **additive only** (no "deny" rules).
* Used to control **who can do what** in Kubernetes.

---

## 🟢 Role vs ClusterRole

* **Role**

  * Namespaced 🔖
  * Defines permissions **only within a namespace**

* **ClusterRole**

  * Cluster-scoped 🌍
  * Can be used for:

    * Cluster-wide resources (e.g., `nodes`)
    * Namespaced resources across **all namespaces**
    * Non-resource endpoints (e.g., `/healthz`)

---

### 📝 Example – Role

📂 `access/simple-role.yaml`

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [""]   # "" = core API group
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
```

---

### 📝 Example – ClusterRole

📂 `access/simple-clusterrole.yaml`

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: secret-reader
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "watch", "list"]
```

---

## 🔵 RoleBinding vs ClusterRoleBinding

* **RoleBinding** → Grants Role (or ClusterRole) permissions **within a namespace**
* **ClusterRoleBinding** → Grants ClusterRole permissions **across the entire cluster**

---

### 📝 Example – RoleBinding

📂 `access/simple-rolebinding-with-role.yaml`

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: default
subjects:
- kind: User
  name: jane   # case sensitive
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role         # Role or ClusterRole
  name: pod-reader   # must match Role/ClusterRole name
  apiGroup: rbac.authorization.k8s.io
```

---

### 📝 Example – ClusterRoleBinding

📂 `access/simple-clusterrolebinding.yaml`

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: read-secrets-global
subjects:
- kind: Group
  name: manager   # case sensitive
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
```

---

## ☁️ RBAC in EKS (IAM vs RBAC)

* **IAM Roles** → AWS-native, used for **authentication** (who you are).
* **Kubernetes RBAC** → Used for **authorization** (what you can do).

👉 In EKS:

* IAM controls **cluster access** (via `aws-auth` ConfigMap).
* RBAC controls **in-cluster permissions**.

---

# 🛠️ Kubernetes Troubleshooting

When things break in K8s, start **from Pods → Services → Ingress → Networking**.

---

## 🟢 Pods & Nodes

```bash
kubectl get pods -n <namespace>
kubectl describe pod <pod-name> -n <namespace>
kubectl logs <pod-name> -c <container-name>
kubectl exec <pod-name> -c <container-name> -- <command>
kubectl get events -n <namespace>
```

Check node state:

```bash
kubectl get nodes
kubectl describe node <node-name>
```

---

## 🔵 Services

Check if Service is exposing correctly:

```bash
kubectl get svc <service-name>
kubectl describe svc <service-name>
```

🔹 Things to check:

* ❓ Does the Service have **endpoints**?

  ```bash
  kubectl get endpoints <service-name>
  ```
* 🔄 Is **kube-proxy** running on nodes?

  ```bash
  ps auxw | grep kube-proxy
  ```
* 🔐 Any **NetworkPolicies** blocking traffic?

---

## 🟠 Ingress

* ✅ Is Ingress Controller running?
* 🔍 Check logs of Ingress Controller:

  ```bash
  kubectl logs <ingress-controller-pod> -n <namespace>
  ```
* 🌐 Verify DNS and ingress rules match service names.

---

⚡ **Pro-Tip**: If backend Pods are working fine, the issue is usually in **Service, Ingress, or Network Policies**.

---
